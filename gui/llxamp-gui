#!/usr/bin/env python3

EXIT_TIMER=500
READLOG_TIMER=2000
STATUS_TIMER=30000

MAX_LINES=1000

import sys,os
import signal
import time
import socket

from gettext import gettext as _
from PySide2 import QtWidgets, QtGui, QtCore

sys.path.insert(1,'/usr/lib/llxamp')
ICON="/usr/share/icons/hicolor/scalable/apps/llxamp.svg"

try:
    llxconfig=__import__('llxamp-config')
except:
    llxconfig=None
    print("Can't import llxamp-config")

app = None
exitting = False

def exit_control_c(sig, frame):
    global app,exitting
    exitting = True
    print(_("Ending QApplication"))
    sys.exit(0)

signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGINT, exit_control_c)

class Highlighter(QtGui.QSyntaxHighlighter):
    def __init__(self,*args, **kwargs):
        super().__init__(*args)
    
    def _format(self, namecolor, style=''):
        color = QtGui.QColor()
        color.setNamedColor(namecolor)
        format = QtGui.QTextCharFormat()
        format.setForeground(color)
        if style == 'bold':
            format.setFontWeight(QtGui.QFont.Bold)
        return format
    
    def highlightBlock(self, text):
        if 'error' in text.lower():
            self.setFormat(0,len(text),self._format('red','bold'))

class Editor(QtWidgets.QWidget):
    editorModified = QtCore.Signal(bool)
    
    def __init__(self,filename,*args, **kwargs):
        super().__init__(*args)
        self._filename = filename
        self._qplaintext = QtWidgets.QPlainTextEdit(self)
        self._qplaintext.setUndoRedoEnabled(True)
        self._toolbar = QtWidgets.QToolBar(self)
        if not self.layout():
            self.setLayout(QtWidgets.QVBoxLayout(self))
        icons = [['document-revert','restore'],['edit-undo','undo'],['edit-redo','redo'],['document-save','save']]
        for (name,data) in icons:
            qt_default = None
            if hasattr(QtWidgets.QStyle,name):
                qt_default = getattr(QtWidgets.QStyle,name) 
            if qt_default:
                icon = self.style().standardIcon(qt_default)
            else:
                icon = QtGui.QIcon.fromTheme(name)
            if not icon.isNull():
                action = QtWidgets.QAction(icon,'',self._toolbar)
            else:
                action = QtWidgets.QAction(data.capitalize(),self._toolbar)
            action.setData(data)
            action.setObjectName(data)
            action.setToolTip(data)
            action.setDisabled(True)
            self._toolbar.addAction(action)
            action.triggered.connect(self._iconPressed)
        self.layout().addWidget(self._toolbar)
        self.layout().addWidget(self._qplaintext)
        self._initialText = ''
        self._textChanged = False
        if os.path.exists(filename):
            with open(filename,'r') as fp:
                self.setInitialText(fp.read())

    def _iconPressed(self):
        action = self.sender()
        data = action.data()
        print(f'Editor button pressed {data}')
        if data == 'restore':
            doc = self._qplaintext.document()
            doc.setPlainText(self._initialText)
        if data == 'undo':
            self._qplaintext.undo()
        if data == 'redo':
            self._qplaintext.redo()
        if data == 'save':
            self.askSave()
            
    def askSave(self):
        if not self.isChanged():
            return 
        dialog = QtWidgets.QMessageBox.question(
            self,
            f'Save file "{self._filename}"',
            f'Desear guardar {self._filename}',
            QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
        )
        if dialog == QtWidgets.QMessageBox.Yes:
            self._savefile()

    def _savefile(self):
        print(f'file {self._filename} saved')
        
    #Only if invokable       
    #@QtCore.Slot(bool)
    def _undoAvailable(self,*args):
        for action in self._toolbar.findChildren(QtWidgets.QAction,'undo'):
            action.setDisabled(self._textChanged)
        pass
    def _redoAvailable(self,status):
        for action in self._toolbar.findChildren(QtWidgets.QAction,'redo'):
            action.setEnabled(status)
        pass
    def setInitialText(self,text):
        self._initialText = text
        self._qplaintext.appendPlainText(text)
        # doc = self._qplaintext.document()
        # cur = QtGui.QTextCursor(doc)
        cur = self._qplaintext.textCursor()
        cur.setPosition(0)
        self._qplaintext.setTextCursor(cur)
        self._qplaintext.textChanged.connect(self._setChanged)
        self._qplaintext.undoAvailable.connect(self._undoAvailable)
        self._qplaintext.redoAvailable.connect(self._redoAvailable)
        
    def appendPlainText(self,text):
        self._qplaintext.appendPlainText(text)

    def _setChanged(self):
        self._textChanged = not (self._initialText == self._qplaintext.toPlainText())
        for action in ( action for action in self._toolbar.actions() if action.objectName() in ['restore','save','undo']):
            action.setEnabled(self._textChanged)
        self.editorModified.emit(self._textChanged)
    
    def isChanged(self):
        return self._textChanged
    
class MainApp(QtWidgets.QMainWindow):
    def __init__(self, app, *args, **kwargs):
        super().__init__()
        self.app = app
        self.process = {}
        self.timers = {}
        self.follow_files = True
        self.files_followed = {}
        self.files = { 'apache' : {}, 'php': {}}
        self.setWindowTitle('LLXAMP')
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.setWindowIcon(icon)

        self.setMinimumSize(QtCore.QSize(800,600))

        self.setCentralWidget(QtWidgets.QWidget(parent=self))
        self.centralWidget().setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        self.begin_build_menubar()
        self.msglabel = QtWidgets.QLabel()
        self.msglabel.setIndent(8)
        font = QtGui.QFont()
        font.setFamilies(['Hack','Courier New','monospace'])
        font.setPointSize(10)
        self.msglabel.setFont(font)
        self.statusBar().addPermanentWidget(self.msglabel,100)
        self.statusBar().setVisible(True)
        self.create_layout()
        self.create_tabs()
        self.create_buttons()
        self.create_text()
        self.create_timers()
        self.create_systray()
        self.action_triggered('status_timer')
        pass

    def changed_tab(self,idx):
        self.msg(f'TAB CHANGE {idx}')

    def close_tab(self,idx):
        self.msg(f'TAB CLOSE {idx}')
        tabs = self.find('tabs')[0]
        widget = tabs.widget(idx)
        if hasattr(widget,'askSave'):
            widget.askSave()
        widget.deleteLater()
        tabs.removeTab(idx)
        if tabs.count() == 0:
            tabs.setVisible(False)

    def create_tabs(self):
        tabs = QtWidgets.QTabWidget(self)
        tabs.setObjectName('tabs')
        tabs.setTabsClosable(True)
        tabs.currentChanged.connect(self.changed_tab)
        tabs.tabCloseRequested.connect(self.close_tab)
        text = QtWidgets.QPlainTextEdit()
        text.setObjectName('tab_tab1')
        tabs.addTab(text,'tab1')
        text2 = QtWidgets.QPlainTextEdit()
        text2.setObjectName('tab_tab2')
        tabs.addTab(text2,'tab2')
        self.split.addWidget(tabs)
        # tabs.setVisible(False)
        
    def follow(self, filename):
        file = self.files_followed.get(filename,None)
        if not file:
            if os.path.exists(filename):
                file = open(filename,'r')
                file.seek(0,2)
                self.files_followed.setdefault(filename,{'fp':file})
                timer = QtCore.QTimer(self)
                timer.timeout.connect(lambda: self.read_logfile(filename))
                timer.start(READLOG_TIMER)
                self.files_followed[filename].setdefault('timer',timer)
                return
        fp=file['fp']
        while self.follow_files:
            # lines = []
            # line = fp.readline().rstrip()
            # while line:
            #     lines.append(line)
            #     line = fp.readline().rstrip()
            # return lines
            return fp.read().splitlines()

    def read_logfile(self, filename):
        lines = self.follow(filename)
        self.msg(lines,f'[{filename.split("/")[-1]}]')
        
    def begin_build_menubar(self):
        if llxconfig:
            llxconfig.set_mode_apache()
            tree,includes,content,logs=llxconfig.process()
            llxconfig.set_mode_php()
            tree2,includes2,content2,logs2=llxconfig.process()
            self.create_menu_bar(config={
                'apache': { 
                    'config files': includes,
                    'log files': logs
                },
                'php': {
                    'config files': includes2,
                    'log files': logs2
                }
            })
        else:
            self.execute_script('llxamp-config',['-a','-p','-t','-i','-l'],finished_fn=lambda:self.create_menu_bar(pname='llxamp-config'),started_fn=lambda: None)

    def closeEvent(self,ev=None,*args):
        self.follow_files = False
        for filename,attrs in self.files_followed.items():
            attrs['fp'].close()
        print('Exit')
        super().closeEvent(ev)
        self.app.quit()

    def systray_activation(self,reason):
        mode = reason.name.decode().lower()
        if mode == 'context':
            print(mode)
        elif mode == 'trigger':
            self.setVisible(not self.isVisible())
        else:
            print(f'TODO: {mode}')
    
    def create_systray(self):
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.systray = QtWidgets.QSystemTrayIcon(icon,self)
        
        self.systray.setVisible(True)
        self.systray.activated.connect(self.systray_activation)
        self.systray.setToolTip("LliureX Apache+MySQL+PHP")
        
        menu=self.find('menu_llxamp')[0]
        self.systray.setContextMenu(menu)

    def create_layout(self):
        l = QtWidgets.QVBoxLayout()
        self.centralWidget().setObjectName('main_layout')
        self.centralWidget().setLayout(l)
        self.split=QtWidgets.QSplitter(self)
        self.split.setOrientation(QtCore.Qt.Vertical)
        self.split.setChildrenCollapsible(False)
        l.addWidget(self.split)
        pass

    def config_to_menu(self,config={}):
        menu = []
        for owner,conf in config.items():
            owner_list = [ owner.capitalize() ]
            for what,files in conf.items():
                if files:
                    what_list = [ what.capitalize() ]
                    for file in files:
                        if what == 'log files':
                            self.follow(file)
                        label = os.path.basename(file)
                        what_list.append(label)
                        self.files[label]=file
                    owner_list.append(what_list)
            menu.append(owner_list)
        return menu

    def output_to_menu(self,text=[]):
        config = {}
        for item in text:
            hint = item.split(':')[0]
            filepath = item.split(':')[1]
            if 'APACHE' in hint:
                config.setdefault('apache',{})
                if 'CONFIG' in hint:
                    config['apache'].setdefault('config files', [])
                    config['apache']['config files'].append(filepath)
                if 'LOG' in hint:
                    config['apache'].setdefault('log files', [])
                    config['apache']['log files'].append(filepath)
            if 'PHP' in hint:
                config.setdefault('php',{})
                if 'CONFIG' in hint:
                    config['php'].setdefault('config files', [])
                    config['php']['config files'].append(filepath)
                if 'LOG' in hint:
                    config['php'].setdefault('log files', [])
                    config['php']['log files'].append(filepath)
        return self.config_to_menu(config)

    def create_menu_bar(self, pname=None, config=None):
        items = []
        if pname:
            out = self.process_stdout(pname)
            out = out.split('\n')
            items = self.output_to_menu(out)
            
        if config:
            items = self.config_to_menu(config)

        # items_example = [
        #     ['File', ['Action1',['SubFile', 'Action2'], 'Action3'] ],
        #     ['File2', ['jeje', 'Ohhh'] ],
        #     'juju'
        # ]

        menu_context_items = ['Llxamp', 'Exit' ]
        menu_context = self.create_menu(items=menu_context_items, parent=self.menuBar())
        self.menuBar().addMenu(menu_context)
        
        for item in items:
            if isinstance(item,list):
                self.menuBar().addMenu(self.create_menu(items=item, parent=self.menuBar()))
            if isinstance(item,str):
                self.menuBar().addAction(self.create_menu(items=item, parent=self.menuBar()))

    def create_menu(self, items=[], parent=None):
        if isinstance(items,list):
            newmenu = QtWidgets.QMenu(items[0].capitalize(),parent=parent)
            newmenu.setObjectName('menu_'+items[0])
            for subitem in items[1:]:
                if isinstance(subitem,list):
                    newmenu.addMenu(self.create_menu(items=subitem, parent=newmenu))
                if isinstance(subitem,str):
                    newmenu.addAction(self.create_menu(items=subitem, parent=newmenu))
            return newmenu
        if isinstance(items,str):
            action = QtWidgets.QAction(items.capitalize(),parent=parent)
            action.setData(items)
            action.setObjectName('action_'+items)
            #action.setStatusTip(items)
            #action.setIcon(QtWidgets.QIcon())
            #action.setShortCuts(QtCore.QKeySequence())
            action.triggered.connect(self.action_triggered)
            return action

    def modification(self,*args):
        # self.msg(f'Document changed {args}')
        sender = self.sender()
        tab = sender.parent().parent()
        idx = tab.indexOf(sender)
        tabIcon = tab.tabIcon(idx)
        icon = self.style().standardIcon(getattr(QtWidgets.QStyle,'SP_DialogSaveButton'))
        if not tabIcon:
            tab.setTabIcon(idx,icon)
        if sender.isChanged():
            tab.setTabIcon(idx,QtGui.QIcon())

    def new_tab(self, filename):
        name = filename.split('/')[-1]
        tab = self.find(f'tab_{name}')
        tabs = self.find('tabs')[0]
        if not tab:
            font = QtGui.QFont()
            font.setFamilies(['Hack','Courier New','monospace'])
            font.setPointSize(10)
            text = Editor(filename)
            text.setObjectName(f'tab_{name}')
            text.setFont(font)
            text.editorModified.connect(self.modification)
            tabs.addTab(text,name)
            tabs.setCurrentIndex(tabs.count()-1)
            self.msg(f'tab created {tabs.count()}')
        else:
            idx = tabs.indexOf(tab[0])
            tabs.setCurrentIndex(idx)
        tabs.setVisible(True)

    def action_triggered(self, name=None):
        action_sender = self.sender()
        parent_name = ''
        if hasattr(action_sender,'parent'):
            parent_name = action_sender.parent().objectName()
        text = None
        data = None
        if action_sender:
            if hasattr(action_sender,'text'):
                text = action_sender.text()
            if hasattr(action_sender,'data'):
                data = action_sender.data()
            if not name:
                name = action_sender.objectName()
        self.msg(f'{self.get_time()} Action trigger {name}')
        txt=[]
        if name:
            txt.append(f'objectName={name}')
        if data:
            txt.append(f'data={data}')
        if text:
            txt.append(f'text={text}')
        if txt:
            txt = ','.join(txt)

        if name == 'status_timer':
            self.execute_script(
                'llxamp-status', ['-a','-m','-p','-n'],
                output_fn=lambda: None,
                started_fn=lambda: None,
                finished_fn=lambda: self.update_status_bar(pname='llxamp-status')
            )
        if name[:6] == 'action':
            if parent_name.lower() == 'menu_llxamp':
                if text.lower() == 'exit':
                    self.closeEvent()
            else:
                file = data
                if file in self.files:
                    file = self.files.get(file)
                self.msg(f'Editing {file}')
                self.new_tab(file)
                pass

        if name[:6] == 'button':
            cmd = name.split('_')[1]
            scriptname = f'llxamp-{cmd}'
            args = []
            prepend=''
            if cmd == 'clear':
                txt=self.find('textarea')
                if txt:
                    txt[0].clear()
                return
            if cmd == 'status':
                args = ['-a','-m','-p','-n']
            if cmd == 'config':
                if not llxconfig:
                    args = ['-a','-p','-c','-r']
                else:
                    llxconfig.set_mode_apache()
                    tree,includes,content,logs = llxconfig.process()
                    txt = llxconfig.print_content(content,False,False)
                    llxconfig.set_mode_php()
                    tree2,includes2,content2,logs = llxconfig.process()
                    txt = f'{txt}{llxconfig.print_content(content2,False,False)}'
                    self.msg(txt,prepend)
                    return
            def output():
                out = self.process_stdout(scriptname)
                self.msg(out,prepend)
                if cmd == 'status':
                    self.update_status_bar(data=out)
                else:
                    QtCore.QTimer.singleShot(3000,lambda: self.action_triggered('status_timer'))
            self.execute_script(
                scriptname, args,
                started_fn=lambda: self.disable_button(name),
                finished_fn=lambda: self.enable_button(name),
                output_fn=output
            )
    
    def disable_button(self,name=None):
        btn = self.find(name)
        if btn:
            btn[0].setDisabled(True)
    
    def enable_button(self,name=None):
        btn = self.find(name)
        if btn:
            btn[0].setEnabled(True)
    
    def update_status_bar(self, pname=None, data=None):
        if not data and pname:
            data = self.process_stdout(pname)
        if data:
            data = { item[0]:item[1] for item in [line.upper().split('=') for line in data.split('\n')] }
            msg = []
            if data.get('APACHE_RUNNING') == '0':
                msg.append('[Apache: Not running]')
            else:
                msg.append(f"[Apache: ports={data.get('APACHE_PORTS')} {len(data.get('APACHE_PROCS','').split(','))} procs]")
            if data.get('MYSQL_RUNNING') == '0':
                msg.append('[MySQL: Not running]')
            else:
                msg.append(f"[MySQL: ports={data.get('MYSQL_PORTS')} {len(data.get('MYSQL_PROCS','').split(','))} procs]")
            #self.statusBar().showMessage(' '.join(msg))
            self.msglabel.setText(' '.join(msg))

    def create_buttons(self):
        buttons = ["status","start","stop","config","clear","open-browser","open-browser-ssl"]
        for txt in buttons:
            btn = QtWidgets.QPushButton(txt.capitalize(),parent=self.split)
            btn.setObjectName('button_'+txt)
            btn.pressed.connect(self.action_triggered)
            self.centralWidget().layout().addWidget(btn)
        pass
    
    def find(self,name=''):
        return self.findChildren(QtWidgets.QWidget,QtCore.QRegularExpression(name,QtCore.QRegularExpression.CaseInsensitiveOption))
    
    def create_timers(self):
        timer = QtCore.QTimer()
        self.timers.setdefault('status',timer)
        timer.setObjectName('status')
        timer.timeout.connect(lambda : self.action_triggered('status_timer'))
        timer.start(STATUS_TIMER)

    def create_text(self):
        text = QtWidgets.QPlainTextEdit()
        doc = text.document()
        doc.setMaximumBlockCount(MAX_LINES)
        font = QtGui.QFont()
        font.setFamilies(['Hack','Courier New','monospace'])
        text.setFont(font)
        Highlighter(doc)
        text.setReadOnly(True)
        text.setObjectName('textarea')
        text.setSizePolicy(QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.MinimumExpanding))
        self.split.addWidget(text)

    def msg(self,txt,prepend=''):
        if txt:
            textarea=self.find('textarea')
            if textarea:
                textarea = textarea[0]
            else:
                return
            txtlines=[]
            if isinstance(txt,str):
                txt=txt.strip()
                txtlines = txt.split('\n')
            if isinstance(txt,list):
                txtlines=txt
            for line in txtlines:
                textarea.appendPlainText(f'{prepend}{line.capitalize()}')

    def finish_script(self,process):
        self.msg(f'finished {process}')
    
    def process_stdout(self,process):
        p = self.process.get(process)
        if p:
            data = bytes(p[0].readAllStandardOutput()).decode('utf8').strip()
            return data
        return ''

    def process_stderr(self,process):
        data = bytes(self.process.get(process)[0].readAllStandardError()).decode('utf8').strip()
        return data

    def get_full_path(self,scriptname):
        full_scriptname = None
        userhome = os.path.expanduser("~")
        paths = ['/usr/bin',f'{userhome}/llxamp/scripts']
        for path in paths:
            if os.path.exists(f'{path}/{scriptname}'):
                full_scriptname = f'{path}/{scriptname}'
                break
        return full_scriptname

    def get_time(self):
        return time.strftime("[%Y-%m-%d %H:%M:%S]", time.gmtime())
    
    def execute_script(self, scriptname, arguments, started_fn=None, finished_fn=None, output_fn=None, error_fn=None):
        if self.process.get(scriptname):
            print(f'Running {scriptname}')
        else:
            p = QtCore.QProcess()
            if not started_fn:
                started_fn = lambda: self.msg(f'started {scriptname}')
            def sfn():
                self.process.setdefault(scriptname,[p])
                self.msg(f'{self.get_time()} started {scriptname}')
                started_fn()
            fn_start = sfn
            if not finished_fn:
                finished_fn = lambda: self.msg(f'finished {scriptname}')
            def ffn():
                self.msg(f'{self.get_time()} finished {scriptname}')
                finished_fn()
                if scriptname in self.process:
                    if output_fn:
                        output_fn()
                    del self.process[scriptname]
            fn_finish = ffn
            # if not output_fn:
            #     output_fn = lambda: self.process_stdout(scriptname)
            # if not error_fn:
            #     error_fn = lambda: self.process_stderr(scriptname)
            
            p.setObjectName(scriptname)
            p.finished.connect(fn_finish)
            p.started.connect(fn_start)
            # p.readyReadStandardOutput.connect(output_fn)
            # p.readyReadStandardError.connect(error_fn)
            full_scriptname = self.get_full_path(scriptname)
            p.start(full_scriptname,arguments)
        
def main():
    global app, exitting
    try:
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.bind('\0llxamp')
    except Exception as e:
        print(f'Already running')
        sys.exit(0)
    app = QtWidgets.QApplication(sys.argv)
    window = MainApp(app)
    window.show()
    exitLoopTimer = QtCore.QTimer()
    exitLoopTimer.timeout.connect(lambda: None)
    exitLoopTimer.start(EXIT_TIMER)
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()

