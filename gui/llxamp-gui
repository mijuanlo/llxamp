#!/usr/bin/env python3

import sys,os
import signal
import time
from gettext import gettext as _
from PySide2 import QtWidgets, QtGui, QtCore

sys.path.insert(1,'/usr/lib/llxamp')

ICON="/usr/share/icons/hicolor/scalable/apps/llxamp.svg"

try:
    llxconfig=__import__('llxamp-config')
except:
    llxconfig=None
    print("Can't import llxamp-config")

app = None
exitting = False

def exit_control_c(sig, frame):
    global app,exitting
    exitting = True
    print(_("Ending QApplication"))
    sys.exit(0)

signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGINT, exit_control_c)

class MainApp(QtWidgets.QMainWindow):
    def __init__(self, app, *args, **kwargs):
        super().__init__()
        self.app = app
        self.process = {}
        self.timers = {}
        self.files = { 'apache' : {}, 'php': {}}
        self.setWindowTitle('LLXAMP')
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.setWindowIcon(icon)

        self.setMinimumSize(QtCore.QSize(800,600))

        self.setCentralWidget(QtWidgets.QWidget(parent=self))
        self.centralWidget().setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        if llxconfig:
            llxconfig.set_mode_apache()
            tree,includes,content,logs=llxconfig.process()
            llxconfig.set_mode_php()
            tree2,includes2,content2,logs2=llxconfig.process()
            self.create_menu_bar(config={
                'apache': { 
                    'config files': includes,
                    'log files': logs
                },
                'php': {
                    'config files': includes2,
                    'log files': logs2
                }
            })
        else:
            self.execute_script('llxamp-config',['-a','-p','-t','-i','-l'],finished_fn=lambda:self.create_menu_bar(pname='llxamp-config'),started_fn=lambda: None)
        #self.create_menu_bar()
        self.msglabel = QtWidgets.QLabel()
        self.statusBar().addPermanentWidget(self.msglabel,100)
        self.create_layout()
        self.create_buttons()
        self.create_text()
        self.create_timers()
        self.statusBar().setVisible(True)
        self.create_systray()
        #self.action_triggered('status_timer')
        pass

    def systray_activation(self,reason):
        mode = reason.name.decode().lower()
        if mode == 'context':
            print(mode)
        elif mode == 'trigger':
            self.setVisible(not self.isVisible())
        else:
            print(f'TODO: {mode}')
    
    def create_systray(self):
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.systray = QtWidgets.QSystemTrayIcon(icon,self)
        self.systray.setVisible(True)
        self.systray.activated.connect(self.systray_activation)
        self.systray.setToolTip("LliureX Apache+MySQL+PHP")
        
        menu = QtWidgets.QMenu(self)
        menu.setVisible(True)
        action = QtWidgets.QAction('Exit',self)
        action.triggered.connect(self.app.quit)
        menu.addAction(action)
        
        self.systray.setContextMenu(menu)

    def create_layout(self):
        l = QtWidgets.QVBoxLayout()
        self.centralWidget().setObjectName('main_layout')
        self.centralWidget().setLayout(l)
        pass

    def config_to_menu(self,config={}):
        menu = []
        for owner,conf in config.items():
            owner_list = [ owner.capitalize() ]
            for what,files in conf.items():
                if files:
                    what_list = [ what.capitalize() ]
                    for file in files:
                        label = os.path.basename(file)
                        what_list.append(label)
                        self.files[label]=file
                    owner_list.append(what_list)
            menu.append(owner_list)
        return menu

    def output_to_menu(self,text=[]):
        config = {}
        for item in text:
            hint = item.split(':')[0]
            filepath = item.split(':')[1]
            if 'APACHE' in hint:
                config.setdefault('apache',{})
                if 'CONFIG' in hint:
                    config['apache'].setdefault('config files', [])
                    config['apache']['config files'].append(filepath)
                if 'LOG' in hint:
                    config['apache'].setdefault('log files', [])
                    config['apache']['log files'].append(filepath)
            if 'PHP' in hint:
                config.setdefault('php',{})
                if 'CONFIG' in hint:
                    config['php'].setdefault('config files', [])
                    config['php']['config files'].append(filepath)
                if 'LOG' in hint:
                    config['php'].setdefault('log files', [])
                    config['php']['log files'].append(filepath)
        return self.config_to_menu(config)

    def create_menu_bar(self, pname=None, config=None):
        items = []
        if pname:
            out = self.process_stdout(pname)
            out = out.split('\n')
            items = self.output_to_menu(out)
            
        if config:
            items = self.config_to_menu(config)

        # items = [
        #     ['File', ['Action1',['SubFile', 'Action2'], 'Action3'] ],
        #     ['File2', ['jeje', 'Ohhh'] ],
        #     'juju'
        # ]

        for item in items:
            if isinstance(item,list):
                self.menuBar().addMenu(self.create_menu(items=item, parent=self.menuBar()))
            if isinstance(item,str):
                self.menuBar().addAction(self.create_menu(items=item, parent=self.menuBar()))
                
    def create_menu(self, items=[], parent=None):
        if isinstance(items,list):
            newmenu = QtWidgets.QMenu(items[0].capitalize(),parent=parent)
            newmenu.setObjectName('menu_'+items[0])
            for subitem in items[1:]:
                if isinstance(subitem,list):
                    newmenu.addMenu(self.create_menu(items=subitem, parent=newmenu))
                if isinstance(subitem,str):
                    newmenu.addAction(self.create_menu(items=subitem, parent=newmenu))
            return newmenu
        if isinstance(items,str):
            action = QtWidgets.QAction(items.capitalize(),parent=parent)
            action.setData(items)
            action.setObjectName('action_'+items)
            #action.setStatusTip(items)
            #action.setIcon(QtWidgets.QIcon())
            #action.setShortCuts(QtCore.QKeySequence())
            action.triggered.connect(self.action_triggered)
            return action

    def action_triggered(self, name=None):
        action_sender = self.sender()
        text = None
        data = None
        if action_sender:
            if hasattr(action_sender,'text'):
                text = action_sender.text()
            if hasattr(action_sender,'data'):
                data = action_sender.data()
            if not name:
                name = action_sender.objectName()
        txt=[]
        if name:
            txt.append(f'objectName={name}')
        if data:
            txt.append(f'data={data}')
        if text:
            txt.append(f'text={text}')
        if txt:
            txt = ','.join(txt)

        if name == 'status_timer':
            self.execute_script(
                'llxamp-status', ['-a','-m','-p','-n'],
                output_fn=lambda: None,
                started_fn=lambda: None,
                finished_fn=lambda: self.update_status_bar(pname='llxamp-status')
            )
        if name[:6] == 'action':
            file = data
            if file in self.files:
                file = self.files.get(file)
            self.msg(f'Editing {file}')
            pass
        if name[:6] == 'button':
            cmd = name.split('_')[1]
            scriptname = f'llxamp-{cmd}'
            args = []
            if cmd == 'clear':
                txt=self.find('textarea')
                if txt:
                    txt[0].clear()
                return
            if cmd == 'status':
                args = ['-a','-m','-p','-n']
            if cmd == 'config':
                if not llxconfig:
                    args = ['-a','-p','-c','-r']
                else:
                    llxconfig.set_mode_apache()
                    tree,includes,content,logs = llxconfig.process()
                    txt = llxconfig.print_content(content,False,False)
                    llxconfig.set_mode_php()
                    tree2,includes2,content2,logs = llxconfig.process()
                    txt = f'{txt}{llxconfig.print_content(content2,False,False)}'
                    self.msg(txt)
                    return
            def output():
                out = self.process_stdout(scriptname)
                self.msg(out)
                if cmd == 'status':
                    self.update_status_bar(data=out)
                else:
                    time.sleep(3)
                    self.action_triggered('status_timer')
            self.execute_script(
                scriptname, args,
                started_fn=lambda: self.disable_button(name),
                finished_fn=lambda: self.enable_button(name),
                output_fn=output
            )
    def disable_button(self,name=None):
        btn = self.find(name)
        if btn:
            btn[0].setDisabled(True)
    
    def enable_button(self,name=None):
        btn = self.find(name)
        if btn:
            btn[0].setEnabled(True)
    
    def update_status_bar(self, pname=None, data=None):
        if not data and pname:
            data = self.process_stdout(pname)
        if data:
            data = { item[0]:item[1] for item in [line.upper().split('=') for line in data.split('\n')] }
            msg = []
            if data.get('APACHE_RUNNING') == '0':
                msg.append('[Apache: Not running]')
            else:
                msg.append(f"[Apache: ports={data.get('APACHE_PORTS')} {len(data.get('APACHE_PROCS','').split(','))} procs]")
            if data.get('MYSQL_RUNNING') == '0':
                msg.append('[MySQL: Not running]')
            else:
                msg.append(f"[MySQL: ports={data.get('MYSQL_PORTS')} {len(data.get('MYSQL_PROCS','').split(','))} procs]")
            #self.statusBar().showMessage(' '.join(msg))
            self.msglabel.setText(' '.join(msg))

    def create_buttons(self):
        buttons = ["status","start","stop","config","clear"]
        for txt in buttons:
            btn = QtWidgets.QPushButton(txt.capitalize(),parent=self.centralWidget())
            btn.setObjectName('button_'+txt)
            btn.pressed.connect(self.action_triggered)
            self.centralWidget().layout().addWidget(btn)
        pass
    
    def find(self,name=''):
        return self.findChildren(QtWidgets.QWidget,QtCore.QRegularExpression(name))
    
    def create_timers(self):
        timer = QtCore.QTimer()
        self.timers.setdefault('status',timer)
        timer.setObjectName('status')
        timer.timeout.connect(lambda : self.action_triggered('status_timer'))
        timer.start(10000)

    def create_text(self):
        text = QtWidgets.QPlainTextEdit()
        text.setReadOnly(True)
        text.setObjectName('textarea')
        self.centralWidget().layout().addWidget(text)

    def msg(self,txt):
        if txt:
            textarea=self.find('textarea')[0]
            txt=txt.strip()
            for line in txt.split('\n'):
                textarea.appendPlainText(line.capitalize())

    def finish_script(self,process):
        self.msg(f'finished {process}')
    
    def process_stdout(self,process):
        p = self.process.get(process)
        if p:
            data = bytes(p[0].readAllStandardOutput()).decode('utf8').strip()
            return data
        return ''

    def process_stderr(self,process):
        data = bytes(self.process.get(process)[0].readAllStandardError()).decode('utf8').strip()
        return data

    def execute_script(self, scriptname, arguments, started_fn=None, finished_fn=None, output_fn=None, error_fn=None):
        if self.process.get(scriptname):
            print(f'Running {scriptname}')
        else:
            p = QtCore.QProcess()
            if not started_fn:
                started_fn = lambda: self.msg(f'started {scriptname}')
            def sfn():
                self.process.setdefault(scriptname,[p])
                # self.msg(f'started {scriptname}')
                started_fn()
            fn_start = sfn
            if not finished_fn:
                finished_fn = lambda: self.msg(f'finished {scriptname}')
            def ffn():
                # self.msg(f'finished {scriptname}')
                finished_fn()
                if scriptname in self.process:
                    if output_fn:
                        output_fn()
                    del self.process[scriptname]
            fn_finish = ffn
            # if not output_fn:
            #     output_fn = lambda: self.process_stdout(scriptname)
            # if not error_fn:
            #     error_fn = lambda: self.process_stderr(scriptname)
            
            p.setObjectName(scriptname)
            p.finished.connect(fn_finish)
            p.started.connect(fn_start)
            # p.readyReadStandardOutput.connect(output_fn)
            # p.readyReadStandardError.connect(error_fn)
            p.start(scriptname,arguments)
        
def main():
    global app, exitting
    
    app = QtWidgets.QApplication(sys.argv)
    window = MainApp(app)
    window.show()
    exitLoopTimer = QtCore.QTimer()
    exitLoopTimer.timeout.connect(lambda: None)
    exitLoopTimer.start(500)
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()

