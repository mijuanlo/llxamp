#!/usr/bin/env python3

DEBUG=False

EXIT_TIMER=500
READLOG_TIMER=2000
STATUS_TIMER=30000

MAX_LINES=1000

import sys,os
import signal
import time
import socket

import gettext
from gettext import gettext as _

gettext.bindtextdomain('llxamp-gui','/usr/share/locale')
gettext.textdomain('llxamp-gui')
from PySide2 import QtWidgets, QtGui, QtCore

sys.path.insert(1,'/usr/lib/llxamp')
ICON="/usr/share/icons/hicolor/scalable/apps/llxamp.svg"

try:
    llxconfig=__import__('llxamp-config')
except:
    llxconfig=None
    print(_("Can't import") + ' llxamp-config')

app = None
exitting = False

def exit_control_c(sig, frame):
    global app,exitting
    exitting = True
    print(_("Ending QApplication"))
    sys.exit(0)

signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGINT, exit_control_c)

def getSignal (oObject : QtCore.QObject, strSignalName : str):
    oMetaObj = oObject.metaObject()
    for i in range (oMetaObj.methodCount()):
        oMetaMethod = oMetaObj.method(i)
        if not oMetaMethod.isValid():
            continue
        if oMetaMethod.methodType () == QtCore.QMetaMethod.Signal and \
            oMetaMethod.name() == strSignalName:
            return oMetaMethod
    return None

def checkSignalConnected(oObject : QtCore.QObject, strSignalName : str):
    return oObject.isSignalConnected(getSignal(oObject,strSignalName))

class Highlighter(QtGui.QSyntaxHighlighter):
    def __init__(self,*args, **kwargs):
        super().__init__(*args)

    def _format(self, namecolor, style=''):
        color = QtGui.QColor()
        color.setNamedColor(namecolor)
        format = QtGui.QTextCharFormat()
        format.setForeground(color)
        if style == 'bold':
            format.setFontWeight(QtGui.QFont.Bold)
        return format

    def highlightBlock(self, text):
        if 'error' in text.lower():
            self.setFormat(0,len(text),self._format('red','bold'))

class Editor(QtWidgets.QWidget):
    editorModified = QtCore.Signal(bool)
    editorSaved = QtCore.Signal(bool)

    def __init__(self,filename=None,*args, **kwargs):
        super().__init__(*args)
        if not filename:
            raise Exception(_('Empty filename'))
        self._filename = filename
        self._data = None
        self._qplaintext = QtWidgets.QPlainTextEdit(self)
        self._qplaintext.setUndoRedoEnabled(True)
        self._toolbar = QtWidgets.QToolBar(self)
        self._actions = {}
        self._restore_content = None
        if not self.layout():
            self.setLayout(QtWidgets.QVBoxLayout(self))
        icons = [['document-revert','restore'],['edit-undo','undo'],['edit-redo','redo'],['document-save','save']]
        for (name,data) in icons:
            qt_default = None
            if hasattr(QtWidgets.QStyle,name):
                qt_default = getattr(QtWidgets.QStyle,name)
            if qt_default:
                icon = self.style().standardIcon(qt_default)
            else:
                icon = QtGui.QIcon.fromTheme(name)
            if not icon.isNull():
                action = QtWidgets.QAction(icon,'',self._toolbar)
            else:
                action = QtWidgets.QAction(data.capitalize(),self._toolbar)
            action.setData(data)
            action.setObjectName(data)
            action.setToolTip(data)
            action.setDisabled(True)
            self._toolbar.addAction(action)
            self._actions.setdefault(data,action)
            action.triggered.connect(self._iconPressed)

        self._qplaintext.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Expanding)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Maximum)
        self.layout().addWidget(self._toolbar)
        self.layout().addWidget(self._qplaintext)
        self._initialText = ''
        self._textChanged = False
        if os.path.exists(filename):
            with open(filename,'r') as fp:
                self.setInitialText(fp.read())

    def setData(self, data):
        self._data = data

    def data(self):
        return self._data

    def _iconPressed(self):
        action = self.sender()
        data = action.data()
        print(_("Editor button pressed")+f' {data}')
        if data == 'restore':
            self.restoreFile()
        if data == 'undo':
            self._qplaintext.undo()
        if data == 'redo':
            self._qplaintext.redo()
        if data == 'save':
            self.askSave()

    def askSave(self, forced=False):
        if self.isChanged() or forced:
            dialog = QtWidgets.QMessageBox.question(
                self,
                _("Save file") + f' "{self._filename}"',
                _("Do you want to save?") + f' {self._filename}',
                QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
            )
            if dialog == QtWidgets.QMessageBox.Yes:
                self._savefile()
                self.editorSaved.emit(True)
            else:
                return True
        return True

    def askRestore(self):
        dialog = QtWidgets.QMessageBox.question(
            self,
            _("Restore file") + f' "{self._filename}"',
            _("Do you want restore original file?") + f' {self._filename}',
            QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
        )
        if dialog == QtWidgets.QMessageBox.No:
            return False
        return True

    def _savefile(self):
        dirname = os.path.dirname(self._filename)
        backupdir = f'{dirname}/backups'
        filename = os.path.basename(self._filename)
        timestamp = MyPyStaticUtils.getTimestamp()
        restorefile = f'{dirname}/.{filename}.initial'
        if not self.hasRestore():
            with open(restorefile,'w') as fp:
                fp.write(self._initialText)
        if not os.path.exists(backupdir):
            os.mkdir(backupdir)
        with open(f'{backupdir}/{filename}.bkp.{timestamp}','w') as fp:
            fp.write(self._initialText)
        contents = self._qplaintext.toPlainText()
        with open(self._filename,'w') as fp:
            fp.write(contents)
        self.setInitialText(contents)
        print(_("File") + f' {self._filename} ' + _("saved"))

    def hasRestore(self):
        if self._restore_content:
            return True
        else:
            dirname = os.path.dirname(self._filename)
            filename = os.path.basename(self._filename)
            restorefile = f'{dirname}/.{filename}.initial'
            exist = os.path.exists(restorefile)
            if exist:
                with open(restorefile,'r') as fp:
                    self._restore_content = fp.read()
        return exist

    def restoreFile(self):
        dirname = os.path.dirname(self._filename)
        filename = os.path.basename(self._filename)
        restorefile = f'{dirname}/.{filename}.initial'
        if self.hasRestore():
            if self.askRestore():
                if self.askSave(forced=True):
                    with open(restorefile,'r') as fprestore:
                        with open(self._filename,'w') as fpfile:
                            content = fprestore.read()
                            self.setInitialText(content)
                            fpfile.write(content)
                            self.editorSaved.emit(True)

    #Only if invokable
    #@QtCore.Slot(bool)
    def _undoAvailable(self,status):
        self._actions.get('undo').setEnabled(status)

    def _redoAvailable(self,status):
        self._actions.get('redo').setEnabled(status)

    def setInitialText(self,text):
        self._initialText = text
        self._qplaintext.clear()
        self._qplaintext.appendPlainText(text)
        self._textChanged = False
        # doc = self._qplaintext.document()
        # cur = QtGui.QTextCursor(doc)
        cur = self._qplaintext.textCursor()
        cur.setPosition(0)
        self._qplaintext.setTextCursor(cur)
        if not checkSignalConnected(self._qplaintext,'textChanged'):
            self._qplaintext.textChanged.connect(self._setChanged)
        if not checkSignalConnected(self._qplaintext,'undoAvailable'):
            self._qplaintext.undoAvailable.connect(self._undoAvailable)
        if not checkSignalConnected(self._qplaintext,'redoAvailable'):
            self._qplaintext.redoAvailable.connect(self._redoAvailable)
        self._qplaintext.document().clearUndoRedoStacks()
        self.hasRestore()
        self._setChanged()

    def appendPlainText(self,text):
        self._qplaintext.appendPlainText(text)

    def _setChanged(self):
        content = self._qplaintext.toPlainText()
        self._textChanged = not (self._initialText == content)
        self._restoreChanged = not (self._restore_content == content)
        self._actions.get('save').setEnabled(self._textChanged)
        self._actions.get('restore').setEnabled(self._restoreChanged)
        self.editorModified.emit(self._textChanged)

    def isChanged(self):
        self._textChanged = not (self._initialText == self._qplaintext.toPlainText())
        return self._textChanged

class LogViewer(QtWidgets.QWidget):
    def __init__(self, *args):
        super().__init__(*args)
        self._follow_files = True
        self._files_followed = {}
        self._textedit = self._create_text_edit(self)
        self._label = QtWidgets.QLabel(_('Log viewer'),self)

        if not self.layout():
            self.setLayout(QtWidgets.QVBoxLayout(self))
        self.layout().setMargin(0)

        self.layout().addWidget(self._label)
        self.layout().addWidget(self._textedit)
        self.setSizePolicy(QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.MinimumExpanding))

    def terminate(self):
        self._follow_files = False
        for filename,attrs in self._files_followed.items():
            attrs['fp'].close()

    def _create_text_edit(self, parent):
        text = QtWidgets.QPlainTextEdit(parent)
        doc = text.document()
        doc.setMaximumBlockCount(MAX_LINES)
        font = QtGui.QFont()
        font.setFamilies(['Hack','Courier New','monospace'])
        text.setFont(font)
        Highlighter(doc)
        text.setReadOnly(True)
        text.setObjectName('textarea')
        text.setSizePolicy(QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.MinimumExpanding))
        return text

    def follow(self, filename):
        file = self._files_followed.get(filename)
        if not file:
            if os.path.exists(filename):
                file = open(filename,'r')
                file.seek(0,2)
                self._files_followed.setdefault(filename,{'fp':file})
                timer = QtCore.QTimer(self)
                timer.timeout.connect(lambda: self._read_logfile(filename))
                timer.start(READLOG_TIMER)
                self._files_followed[filename].setdefault('timer',timer)
                if DEBUG:
                    self.msg(_("Following logfile") + f' {filename}')
                return
        fp=file['fp']
        while self._follow_files:
            # lines = []
            # line = fp.readline().rstrip()
            # while line:
            #     lines.append(line)
            #     line = fp.readline().rstrip()
            # return lines
            return fp.read().splitlines()

    def _read_logfile(self, filename):
        lines = self.follow(filename)
        self.msg(lines,f'[{filename.split("/")[-1]}]')

    def msg(self,txt='',prepend=''):
        if txt:
            txtlines=[]
            if isinstance(txt,str):
                txt=txt.strip()
                txtlines = txt.splitlines()
            if isinstance(txt,list):
                txtlines=txt
            for line in txtlines:
                self._textedit.appendPlainText(f'{prepend}{line.capitalize()}')

class MyPyStaticUtils():
    def getTime():
        return time.strftime("[%Y-%m-%d %H:%M:%S]", time.gmtime())

    def getTimestamp():
        return time.strftime("%Y%m%d%H%M%S", time.gmtime())

    def getScriptFullPath(scriptname):
        full_scriptname = None
        userhome = os.path.expanduser("~")
        paths = ['/usr/bin',f'{userhome}/llxamp/scripts']
        for path in paths:
            if os.path.exists(f'{path}/{scriptname}'):
                full_scriptname = f'{path}/{scriptname}'
                break
        return full_scriptname

class MyAppConfigFiles():
    APACHE_TAG = 'APACHE'
    PHP_TAG = 'PHP'
    CONFIGFILES_TAG = 'CONFFILES'
    LOGFILES_TAG= 'LOGFILES'

    def __init__(self,txt=[]):
        self.apache_confs = []
        self.apache_logs = []
        self.php_confs = []
        self.php_logs = []
        if txt:
            if isinstance(txt,(list,str)):
                self.set_from_output(txt)
            if isinstance(txt,dict):
                self.set_from_config(txt)

    def to_config(self):
        data={
            self.APACHE_TAG: {
                self.CONFIGFILES_TAG: self.apache_confs,
                self.LOGFILES_TAG: self.apache_logs
            },
            self.PHP_TAG: {
                self.CONFIGFILES_TAG: self.php_confs,
                self.LOGFILES_TAG: self.php_logs
            }
        }
        return data

    def get_mappings(self):
        return self.get_mappings_from_config(self.to_config())

    def get_mappings_from_config(self, config):
        mappings = {}
        for owner,conf in config.items():
            for what,files in conf.items():
                if files:
                    for file in files:
                        mappings.setdefault(file.split('/')[-1],file)
        return mappings

    def get_logfiles(self):
        return self.get_logfiles_from_config(self.to_config())

    def get_logfiles_from_config(self, config):
        logfiles = []
        for owner,conf in config.items():
            for what,files in conf.items():
                if what == self.LOGFILES_TAG:
                    if files:
                        for file in files:
                            logfiles.append(file)
        return logfiles

    def get_menu(self):
        return self.config_to_menu(self.to_config())

    def config_to_menu(self, config={}):
        menu = []
        for owner,conf in config.items():
            owner_list = [ owner.capitalize() ]
            for what,files in conf.items():
                if files:
                    what_list = [ what.capitalize() ]
                    for file in files:
                        label = os.path.basename(file)
                        what_list.append(label)
                    owner_list.append(what_list)
            menu.append(owner_list)
        return menu

    def output_to_menu(self, text=[]):
        return self.config_to_menu(self.output_to_config(text))

    def set_from_output(self, text=[]):
        cfg = self.output_to_config(text)
        self.set_from_config(cfg)

    def set_from_config(self, cfg={}):
        self.apache_confs = cfg.get(self.APACHE_TAG).get(self.CONFIGFILES_TAG)
        self.apache_logs = cfg.get(self.APACHE_TAG).get(self.LOGFILES_TAG)
        self.php_confs = cfg.get(self.PHP_TAG).get(self.CONFIGFILES_TAG)
        self.php_logs = cfg.get(self.PHP_TAG).get(self.LOGFILES_TAG)

    def output_to_config(self, text=[]):
        if isinstance(text,str):
            text=text.splitlines()
        config = {}
        for item in text:
            hint = item.split(':')[0]
            filepath = item.split(':')[1]
            filepath = filepath.strip()
            if self.APACHE_TAG in hint:
                config.setdefault(self.APACHE_TAG,{})
                if 'CONFIG' in hint:
                    config[self.APACHE_TAG].setdefault(self.CONFIGFILES_TAG, [])
                    config[self.APACHE_TAG][self.CONFIGFILES_TAG].append(filepath)
                if 'LOG' in hint:
                    config[self.APACHE_TAG].setdefault(self.LOGFILES_TAG, [])
                    config[self.APACHE_TAG][self.LOGFILES_TAG].append(filepath)
            if self.PHP_TAG in hint:
                config.setdefault(self.PHP_TAG,{})
                if 'CONFIG' in hint:
                    config[self.PHP_TAG].setdefault(self.CONFIGFILES_TAG, [])
                    config[self.PHP_TAG][self.CONFIGFILES_TAG].append(filepath)
                if 'LOG' in hint:
                    config[self.PHP_TAG].setdefault(self.LOGFILES_TAG, [])
                    config[self.PHP_TAG][self.LOGFILES_TAG].append(filepath)
        return config

class MyQtStaticUtils():
    def findObject(object,name=''):
        return object.findChildren(QtWidgets.QWidget,QtCore.QRegularExpression(name,QtCore.QRegularExpression.CaseInsensitiveOption))

    def create_menu(items=[], receiver=None, parent=None):
        if isinstance(items,list):
            newmenu = QtWidgets.QMenu(items[0].capitalize(),parent=parent)
            newmenu.setObjectName('menu_'+items[0])
            for subitem in items[1:]:
                if isinstance(subitem,list):
                    newmenu.addMenu(MyQtStaticUtils.create_menu(items=subitem, receiver=receiver, parent=newmenu))
                if isinstance(subitem,str):
                    newmenu.addAction(MyQtStaticUtils.create_menu(items=subitem, receiver=receiver, parent=newmenu))
            return newmenu
        if isinstance(items,str):
            action = QtWidgets.QAction(items.capitalize(),parent=parent)
            action.setData(items)
            action.setObjectName('action_'+items)
            #action.setStatusTip(items)
            #action.setIcon(QtWidgets.QIcon())
            #action.setShortCuts(QtCore.QKeySequence())
            action.triggered.connect(receiver)
            return action

class QtProc():
    def __init__(self):
        self.process = {}

    def executeSingletonScript(self, scriptname, arguments, started_fn=None, finished_fn=None, debug_fn=None):

        def process_stdout(process):
            p = self.process.get(process)
            if p:
                data = bytes(p[0].readAllStandardOutput()).decode('utf8').strip()
                return data
            return ''

        def process_stderr(process):
            data = bytes(self.process.get(process)[0].readAllStandardError()).decode('utf8').strip()
            return data

        if not DEBUG:
            debug_fn = lambda x: None

        if not debug_fn:
            debug_fn = print

        debug_start_fn = lambda: debug_fn(f'{MyPyStaticUtils.getTime()} Started {scriptname}')
        debug_finish_fn = lambda x: debug_fn(f'{MyPyStaticUtils.getTime()} Finished {scriptname}\n{x}\n')

        if not started_fn:
            started_fn = debug_start_fn

        if not finished_fn:
            finished_fn = debug_finish_fn

        if self.process.get(scriptname):
            debug_fn(_("Already running") + f' {scriptname}')
            return

        process = QtCore.QProcess()
        process.setObjectName(scriptname)

        def sfn():
            self.process.setdefault(scriptname, [process])
            debug_start_fn()
            started_fn()

        def ffn():
            out = process_stdout(scriptname)
            err = process_stderr(scriptname)
            if err:
                debug_finish_fn(_("Error executing script") + f' {scriptname}')
            debug_finish_fn({'out': out, 'err': err})
            finished_fn(out)
            if scriptname in self.process:
                del self.process[scriptname]

        fn_start = sfn
        fn_finish = ffn

        process.finished.connect(fn_finish)
        process.started.connect(fn_start)

        process.start(MyPyStaticUtils.getScriptFullPath(scriptname),arguments)

class MainApp(QtWidgets.QMainWindow):
    def __init__(self, app, *args, **kwargs):
        super().__init__()
        self.app = app
        self.qtproc = QtProc()
        self.logviewer = LogViewer(self)
        self.timers = {}
        self.file_mappings = {}

        self.setWindowTitle('LLXAMP')
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)

        self.setWindowIcon(icon)

        self.setMinimumSize(QtCore.QSize(800,600))

        self.setCentralWidget(QtWidgets.QWidget(parent=self))
        self.centralWidget().setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        self.begin_build_menubar()
        self.msglabel = QtWidgets.QLabel()
        self.msglabel.setIndent(8)
        font = QtGui.QFont()
        font.setFamilies(['Hack','Courier New','monospace'])
        font.setPointSize(10)
        self.msglabel.setFont(font)
        self.statusBar().addPermanentWidget(self.msglabel,100)
        self.statusBar().setVisible(True)
        self.create_layout()
        self.create_tabs()
        self.create_buttons()
        self.split.addWidget(self.logviewer)
        self.create_timers()
        self.create_systray()
        self.action_triggered('status_timer')
        pass

    def changed_tab(self,idx):
        if DEBUG:
            self.msg(f'TAB CHANGE {idx}')

    def close_tab(self,idx,forced=False):
        tabs = MyQtStaticUtils.findObject(self,'tabs')
        if not tabs:
            return False
        tabs = tabs[0]
        widget = tabs.widget(idx)
        if forced == False:
            dialog = QtWidgets.QMessageBox.question(
                self,
                _("Close tab"),
                _("Do you want close the tab?") + f' "{widget.data()}"',
                QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
            )
            if dialog == QtWidgets.QMessageBox.No:
                return False
        if DEBUG:
            self.msg(_("TAB CLOSE") + f' {idx}')

        if hasattr(widget,'askSave'):
            ret = widget.askSave()
            if not ret:
                return False
        widget.deleteLater()
        tabs.removeTab(idx)
        if tabs.count() == 0:
            tabs.setVisible(False)
        return True

    def create_tabs(self):
        tabs = QtWidgets.QTabWidget(self)
        tabs.setObjectName('tabs')
        tabs.setTabsClosable(True)
        tabs.currentChanged.connect(self.changed_tab)
        tabs.tabCloseRequested.connect(self.close_tab)
        # text = QtWidgets.QPlainTextEdit()
        # text.setObjectName('tab_exampletab1')
        # tabs.addTab(text,'exampletab1')
        # text2 = QtWidgets.QPlainTextEdit()
        # text2.setObjectName('tab_exampletab2')
        # tabs.addTab(text2,'exampletab2')
        self.split.addWidget(tabs)
        tabs.setVisible(False)

    def begin_build_menubar(self):
        menu_context_items = ['Llxamp', 'Exit' ]
        menu_context = MyQtStaticUtils.create_menu(
            items=menu_context_items,
            receiver=self.action_triggered,
            parent=self.menuBar()
        )
        self.menuBar().addMenu(menu_context)

        def post_actions(x):
            x = MyAppConfigFiles(x)
            self.update_menu_bar(data=x)
            if x:
                self.file_mappings = x.get_mappings()
                for f in x.get_logfiles():
                    self.logviewer.follow(f)

        if llxconfig:
            cfg = MyAppConfigFiles()
            llxconfig.set_mode_apache()
            hierarchy, includes, content, logs=llxconfig.process()
            cfg.apache_confs = includes
            cfg.apache_logs = logs
            llxconfig.set_mode_php()
            hierarchy2, includes2, content2, logs2=llxconfig.process()
            cfg.php_confs = includes2
            cfg.php_logs = logs2
            post_actions(cfg.to_config())
        else:

            self.qtproc.executeSingletonScript(
                'llxamp-config',['-a','-p','-t','-i','-l'],
                finished_fn=post_actions,
                debug_fn=self.msg
            )

    def closeEvent(self,ev=None,*args):
        for tabs in MyQtStaticUtils.findObject(self,'tabs'):
            if tabs.objectName() == 'tabs':
                for idx in range(tabs.count()):
                    widget=tabs.widget(idx)
                    if isinstance(widget,Editor):
                        if not self.close_tab(idx,forced=True):
                            if hasattr(ev,'ignore'):
                                ev.ignore()
                            return
        self.logviewer.terminate()

        print(_('Exit'))
        super().closeEvent(ev)
        self.app.quit()

    def systray_activation(self,reason):
        mode = reason.name.decode().lower()
        if mode == 'context':
            print(mode)
        elif mode == 'trigger':
            self.setVisible(not self.isVisible())
        else:
            print(f'TODO: {mode}')

    def create_systray(self):
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.systray = QtWidgets.QSystemTrayIcon(icon,self)

        self.systray.setVisible(True)
        self.systray.activated.connect(self.systray_activation)
        self.systray.setToolTip("LliureX Apache+MySQL+PHP")

        menu = MyQtStaticUtils.findObject(self,'menu_llxamp')
        if not menu:
            return False
        menu = menu[0]
        self.systray.setContextMenu(menu)

    def create_layout(self):
        l = QtWidgets.QVBoxLayout()
        self.centralWidget().setObjectName('main_layout')
        self.centralWidget().setLayout(l)
        self.split=QtWidgets.QSplitter(self)
        self.split.setOrientation(QtCore.Qt.Vertical)
        self.split.setChildrenCollapsible(False)
        l.addWidget(self.split)

    def update_menu_bar(self, data=None):
        items = []
        if not isinstance(data,MyAppConfigFiles):
            data = MyAppConfigFiles(data)
        items = data.get_menu()

        # items_example = [
        #     ['File', ['Action1',['SubFile', 'Action2'], 'Action3'] ],
        #     ['File2', [Action4, Action5] ],
        #     Action6
        # ]

        for item in items:
            if isinstance(item,list):
                self.menuBar().addMenu(
                    MyQtStaticUtils.create_menu(
                        items = item,
                        receiver = self.action_triggered,
                        parent = self.menuBar()
                    )
                )
            if isinstance(item,str):
                self.menuBar().addAction(
                    MyQtStaticUtils.create_menu(
                        items = item,
                        receiver = self.action_triggered,
                        parent=self.menuBar()
                    )
                )

    def modification_slot(self,*args):
        # self.msg(f'Document changed {args}')
        sender = self.sender()
        tab = sender.parent().parent()
        idx = tab.indexOf(sender)
        icon = self.style().standardIcon(getattr(QtWidgets.QStyle,'SP_DialogSaveButton'))

        if sender.isChanged():
            tab.setTabIcon(idx,icon)
        else:
            tab.setTabIcon(idx,QtGui.QIcon())

    def editor_save_slot(self):
        self.menuBar().clear()
        self.begin_build_menubar()


    def new_tab(self, filename):
        name = filename.split('/')[-1]
        tabs = MyQtStaticUtils.findObject(self,'tabs')
        if not tabs:
            return False
        tabs = tabs[0]
        tab = MyQtStaticUtils.findObject(self,f'tab_{name}')
        if not tab:
            font = QtGui.QFont()
            font.setFamilies(['Hack','Courier New','monospace'])
            font.setPointSize(10)
            text = Editor(self.file_mappings.get(filename))
            text.setObjectName(f'tab_{name}')
            text.setFont(font)
            text.setData(filename)
            text.editorModified.connect(self.modification_slot)
            text.editorSaved.connect(self.editor_save_slot)
            tabs.addTab(text,name)
            tabs.setCurrentIndex(tabs.count()-1)
            if DEBUG:
                self.msg(_("Tab created") + f' {tabs.count()}')
        else:
            idx = tabs.indexOf(tab[0])
            tabs.setCurrentIndex(idx)
        tabs.setVisible(True)

    def action_triggered(self, name=None):
        action_sender = self.sender()
        parent_name = ''
        if hasattr(action_sender,'parent'):
            parent_name = action_sender.parent().objectName()
        text = None
        data = None
        if action_sender:
            if hasattr(action_sender,'text'):
                text = action_sender.text()
            if hasattr(action_sender,'data'):
                data = action_sender.data()
            if not name:
                name = action_sender.objectName()
        if DEBUG:
            self.msg(f'{MyPyStaticUtils.getTime()} Action trigger {name}')
        txt=[]
        if name:
            txt.append(f'objectName={name}')
        if data:
            txt.append(f'data={data}')
        if text:
            txt.append(f'text={text}')
        if txt:
            txt = ','.join(txt)

        if name == 'status_timer':
            self.qtproc.executeSingletonScript(
                'llxamp-status', ['-a','-m','-p','-n'],
                debug_fn=self.msg,
                finished_fn=lambda x: self.update_status_bar(data=x)
            )

        if name[:6] == 'action':
            if parent_name.lower() == 'menu_llxamp':
                if text.lower() == 'exit':
                    self.closeEvent()
            else:
                file = data
                if DEBUG:
                    self.msg(_("Editing") + f' {file}')
                self.new_tab(file)
                pass

        if name[:6] == 'button':
            button = MyQtStaticUtils.findObject(self,name)
            if button:
                button = button[0]
            cmd = name.split('_')[1]
            scriptname = f'llxamp-{cmd}'
            args = []
            prepend=''
            if cmd == 'clear':
                txt=MyQtStaticUtils.findObject(self,'textarea')
                if not txt:
                    return
                txt[0].clear()
                return
            if cmd == 'status':
                args = ['-a','-m','-p','-n']
            if cmd == 'config':
                if not llxconfig:
                    args = ['-a','-p','-c','-r']
                else:
                    llxconfig.set_mode_apache()
                    tree,includes,content,logs = llxconfig.process()
                    txt = llxconfig.print_content(content,False,False)
                    llxconfig.set_mode_php()
                    tree2,includes2,content2,logs = llxconfig.process()
                    txt = f'{txt}{llxconfig.print_content(content2,False,False)}'
                    self.msg(txt,prepend)
                    return

            # Common "output" parameter for button actions
            def output(x):
                if DEBUG:
                    self.msg(_('Output from command') + f' {scriptname}:\n{x}\n',prepend)
                else:
                    self.msg(x)
                button.setEnabled(True)
                if cmd == 'status':
                    self.update_status_bar(data=x)
                else:
                    QtCore.QTimer.singleShot(3000,lambda: self.action_triggered('status_timer'))

            self.qtproc.executeSingletonScript(
                scriptname, args,
                started_fn=lambda: button.setDisabled(True),
                finished_fn=lambda x: output(x),
                debug_fn=self.msg
            )

    def update_status_bar(self, data = None):
        if data:
            data = { item[0]:item[1] for item in [line.upper().split('=') for line in data.split('\n')] }
            msg = []
            notrunstr = _("Not running")
            if data.get('APACHE_RUNNING') == '0':
                msg.append(f'[Apache: {notrunstr}]')
            else:
                msg.append(f"[Apache: ports={data.get('APACHE_PORTS')} {len(data.get('APACHE_PROCS','').split(','))} procs]")
            if data.get('MYSQL_RUNNING') == '0':
                msg.append(f'[MySQL: {notrunstr}]')
            else:
                msg.append(f"[MySQL: ports={data.get('MYSQL_PORTS')} {len(data.get('MYSQL_PROCS','').split(','))} procs]")
            #self.statusBar().showMessage(' '.join(msg))
            self.msglabel.setText(' '.join(msg))

    def create_buttons(self):
        buttons = ["#status","start","stop","#config","clear","open-browser","open-browser-ssl"]
        for txt in buttons:
            if txt[0] != '#':
                btn = QtWidgets.QPushButton(txt.capitalize(),parent=self.split)
                btn.setObjectName('button_'+txt)
                btn.pressed.connect(self.action_triggered)
                self.centralWidget().layout().addWidget(btn)
        pass

    def create_timers(self):
        timer = QtCore.QTimer()
        self.timers.setdefault('status',timer)
        timer.setObjectName('status')
        timer.timeout.connect(lambda : self.action_triggered('status_timer'))
        timer.start(STATUS_TIMER)

    def msg(self, txt='', prepend=''):
        self.logviewer.msg(txt,prepend)

def main():
    global app, exitting
    try:
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.bind('\0llxamp')
    except Exception as e:
        print(_("Already running"))
        sys.exit(0)
    app = QtWidgets.QApplication(sys.argv)
    window = MainApp(app)
    window.show()
    exitLoopTimer = QtCore.QTimer()
    exitLoopTimer.timeout.connect(lambda: None)
    exitLoopTimer.start(EXIT_TIMER)
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()

