#!/usr/bin/env python3

"""
 Copyright (C) 2023 M.Angel Juan

 This file is part of LLXAMP.

 LLXAMP is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 LLXAMP is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with LLXAMP.  If not, see <http://www.gnu.org/licenses/>.
"""

DEBUG=False

EXIT_TIMER=500
READLOG_TIMER=2000
STATUS_TIMER=30000

MAX_LINES=1000

import sys,os
import signal
import time
import socket

import gettext
from gettext import gettext as _

gettext.bindtextdomain('llxamp-gui','/usr/share/locale')
gettext.textdomain('llxamp-gui')
from PySide2 import QtWidgets, QtGui, QtCore

sys.path.insert(1,'/usr/lib/llxamp')
ICON="/usr/share/icons/hicolor/scalable/apps/llxamp.svg"

try:
    llxconfig=__import__('llxamp-config')
except:
    llxconfig=None
    print(_("Can't import") + ' llxamp-config')

app = None
exitting = False

def exit_control_c(sig, frame):
    global app,exitting
    exitting = True
    print(_("Ending QApplication"))
    sys.exit(0)

signal.signal(signal.SIGINT, signal.SIG_DFL)
signal.signal(signal.SIGINT, exit_control_c)

def getSignal (oObject : QtCore.QObject, strSignalName : str):
    oMetaObj = oObject.metaObject()
    for i in range (oMetaObj.methodCount()):
        oMetaMethod = oMetaObj.method(i)
        if not oMetaMethod.isValid():
            continue
        if oMetaMethod.methodType () == QtCore.QMetaMethod.Signal and \
            oMetaMethod.name() == strSignalName:
            return oMetaMethod
    return None

def checkSignalConnected(oObject : QtCore.QObject, strSignalName : str):
    return oObject.isSignalConnected(getSignal(oObject,strSignalName))

class Highlighter(QtGui.QSyntaxHighlighter):
    def __init__(self,*args, **kwargs):
        super().__init__(*args)

    def _format(self, namecolor, style=''):
        color = QtGui.QColor()
        color.setNamedColor(namecolor)
        format = QtGui.QTextCharFormat()
        format.setForeground(color)
        if style == 'bold':
            format.setFontWeight(QtGui.QFont.Bold)
        return format

    def highlightBlock(self, text):
        if text:
            idx = 0
            if text[0] == '[':
                idx = text.index(']') + 1
            if 'error' in text[idx:].lower():
                self.setFormat(0,len(text),self._format('red','bold'))

class Editor(QtWidgets.QWidget):
    editorModified = QtCore.Signal(bool)
    editorSaved = QtCore.Signal(bool)
    editorExternal = QtCore.Signal(str)

    def __init__(self,filename=None,*args, **kwargs):
        super().__init__(*args)
        if not filename:
            raise Exception(_('Empty filename'))
        self._filename = filename
        self._data = None
        self._qplaintext = QtWidgets.QPlainTextEdit(self)
        self._qplaintext.setUndoRedoEnabled(True)
        self._toolbar = QtWidgets.QToolBar(self)
        self._actions = {}
        self._restore_content = None
        if not self.layout():
            self.setLayout(QtWidgets.QVBoxLayout(self))
        icons = [['document-revert','restore',_('Restore initial file')],['edit-undo','undo',_('Undo')],['edit-redo','redo',_('Redo')],['document-save','save',_('Save')],['open-for-editing','external-edit',_('Open with system editor')]]
        for (name,data,txt) in icons:
            qt_default = None
            if hasattr(QtWidgets.QStyle,name):
                qt_default = getattr(QtWidgets.QStyle,name)
            if qt_default:
                icon = self.style().standardIcon(qt_default)
            else:
                icon = QtGui.QIcon.fromTheme(name)
            if not icon.isNull():
                action = QtWidgets.QAction(icon,'',self._toolbar)
            else:
                action = QtWidgets.QAction(data.capitalize(),self._toolbar)
            action.setData(data)
            action.setObjectName(data)
            action.setToolTip(txt)
            if data not in ['external-edit']:
                action.setDisabled(True)
            self._toolbar.addAction(action)
            self._actions.setdefault(data,action)
            action.triggered.connect(self._iconPressed)

        self._qplaintext.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Expanding)
        self.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Maximum)
        self.layout().addWidget(self._toolbar)
        self.layout().addWidget(self._qplaintext)
        self._initialText = ''
        self._textChanged = False
        if os.path.exists(filename):
            with open(filename,'r') as fp:
                self.setInitialText(fp.read())
        self._make_restore_file()

    def setData(self, data):
        self._data = data

    def data(self):
        return self._data

    def _iconPressed(self):
        action = self.sender()
        data = action.data()
        if DEBUG:
            print(_("Editor button pressed")+f' {data}')
        if data == 'restore':
            self.restoreFile()
        if data == 'undo':
            self._qplaintext.undo()
        if data == 'redo':
            self._qplaintext.redo()
        if data == 'save':
            self.askSave()
        if data == 'external-edit':
            self.editorExternal.emit(data)

    def askSave(self, exit_forced=False):
        if self.isChanged() or exit_forced:
            dialog = QtWidgets.QMessageBox.question(
                self,
                _("Save file") + f' "{self._filename}"',
                _("Do you want to save?") + f' {self._filename}',
                QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
            )
            if dialog == QtWidgets.QMessageBox.Yes:
                self._savefile()
                self.editorSaved.emit(True)
            else:
                return True
        return True

    def askRestore(self):
        dialog = QtWidgets.QMessageBox.question(
            self,
            _("Restore file") + f' "{self._filename}"',
            _("Do you want restore original file?") + f' {self._filename}',
            QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
        )
        if dialog == QtWidgets.QMessageBox.No:
            return False
        return True

    def _make_restore_file(self):
        dirname = os.path.dirname(self._filename)
        filename = os.path.basename(self._filename)
        restorefile = f'{dirname}/.{filename}.initial'
        if not self.hasRestore():
            with open(restorefile,'w') as fp:
                fp.write(self._initialText)

    def _savefile(self):
        dirname = os.path.dirname(self._filename)
        backupdir = f'{dirname}/backups'
        filename = os.path.basename(self._filename)
        timestamp = MyPyStaticUtils.getTimestamp()
        self._make_restore_file()
        if not os.path.exists(backupdir):
            os.mkdir(backupdir)
        with open(f'{backupdir}/{filename}.bkp.{timestamp}','w') as fp:
            fp.write(self._initialText)
        contents = self._qplaintext.toPlainText()
        with open(self._filename,'w') as fp:
            fp.write(contents)
        cur = self._qplaintext.textCursor()
        pos = cur.position()
        self.setInitialText(contents)
        cur = self._qplaintext.textCursor()
        cur.movePosition(QtGui.QTextCursor.Start,QtGui.QTextCursor.MoveAnchor,1)
        cur.movePosition(QtGui.QTextCursor.NextCharacter,QtGui.QTextCursor.MoveAnchor,pos-1)
        self._qplaintext.setTextCursor(cur)
        print(_("File") + f' {self._filename} ' + _("saved"))

    def hasRestore(self):
        if self._restore_content:
            return True
        else:
            dirname = os.path.dirname(self._filename)
            filename = os.path.basename(self._filename)
            restorefile = f'{dirname}/.{filename}.initial'
            exist = os.path.exists(restorefile)
            if exist:
                with open(restorefile,'r') as fp:
                    self._restore_content = fp.read()
        return exist

    def restoreFile(self):
        dirname = os.path.dirname(self._filename)
        filename = os.path.basename(self._filename)
        restorefile = f'{dirname}/.{filename}.initial'
        if self.hasRestore():
            if self.askRestore():
                if self.askSave(exit_forced=True):
                    with open(restorefile,'r') as fprestore:
                        with open(self._filename,'w') as fpfile:
                            content = fprestore.read()
                            self.setInitialText(content)
                            fpfile.write(content)
                            self.editorSaved.emit(True)

    #Only if invokable
    #@QtCore.Slot(bool)
    def _undoAvailable(self,status):
        self._actions.get('undo').setEnabled(status)

    def _redoAvailable(self,status):
        self._actions.get('redo').setEnabled(status)

    def setInitialText(self,text):
        self._initialText = text
        self._qplaintext.clear()
        self._qplaintext.appendPlainText(text)
        self._textChanged = False
        # doc = self._qplaintext.document()
        # cur = QtGui.QTextCursor(doc)
        cur = self._qplaintext.textCursor()
        cur.setPosition(0)
        self._qplaintext.setTextCursor(cur)
        if not checkSignalConnected(self._qplaintext,'textChanged'):
            self._qplaintext.textChanged.connect(self._setChanged)
        if not checkSignalConnected(self._qplaintext,'undoAvailable'):
            self._qplaintext.undoAvailable.connect(self._undoAvailable)
        if not checkSignalConnected(self._qplaintext,'redoAvailable'):
            self._qplaintext.redoAvailable.connect(self._redoAvailable)
        self._qplaintext.document().clearUndoRedoStacks()
        self.hasRestore()
        self._setChanged()

    def appendPlainText(self,text):
        self._qplaintext.appendPlainText(text)

    def _setChanged(self):
        content = self._qplaintext.toPlainText()
        self._textChanged = not (self._initialText == content)
        self._restoreChanged = not (self._restore_content == content)
        self._actions.get('save').setEnabled(self._textChanged)
        self._actions.get('restore').setEnabled(self._restoreChanged)
        self.editorModified.emit(self._textChanged)

    def isChanged(self):
        self._textChanged = not (self._initialText == self._qplaintext.toPlainText())
        return self._textChanged

class LogViewer(QtWidgets.QWidget):
    def __init__(self, *args):
        super().__init__(*args)
        self._follow_files = True
        self._files_followed = {}
        self._textedit = self._create_text_edit(self)
        self._label = QtWidgets.QLabel(_('Log viewer'),self)
        self._label.setIndent(8)

        self._head_container = QtWidgets.QWidget(self)
        self._clear_button = QtWidgets.QPushButton(self._head_container)
        self._clear_button.setSizePolicy(QtWidgets.QSizePolicy.Fixed,QtWidgets.QSizePolicy.Fixed)
        self._clear_button.setText(_('Clear'))
        self._clear_button.setObjectName('button_clear')
        self._clear_button.pressed.connect(self.clear)
        self._showhide_button = QtWidgets.QPushButton(self._head_container)
        self._showhide_button.setSizePolicy(QtWidgets.QSizePolicy.Fixed,QtWidgets.QSizePolicy.Fixed)
        self._showhide_button.setText(_('Hide'))
        self._showhide_button.setObjectName('button_showhide')
        self._showhide_button.pressed.connect(self.show_hide)

        if not self._head_container.layout():
            self._head_container.setLayout(QtWidgets.QHBoxLayout(self._head_container))
            self._head_container.layout().setMargin(0)
            self._head_container.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Fixed)

        self._head_container.layout().addWidget(self._label)
        self._head_container.layout().addItem(QtWidgets.QSpacerItem(0,0,QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Expanding))
        self._head_container.layout().addWidget(self._clear_button)
        self._head_container.layout().addWidget(self._showhide_button)
        if not self.layout():
            self.setLayout(QtWidgets.QVBoxLayout(self))
        self.layout().setMargin(0)
        self.layout().addWidget(self._head_container)
        self.layout().setAlignment(QtCore.Qt.AlignBottom)
        # sizep = self._textedit.sizePolicy()
        # sizep.setRetainSizeWhenHidden(True)
        # self._textedit.setSizePolicy(sizep)
        self.layout().addWidget(self._textedit)
        self.setMinimumSize(0,0)

    def clear(self):
        self._textedit.clear()

    def show_hide(self):
        visible = self._textedit.isVisible()
        self._textedit.setVisible( not visible)
        if visible:
            text = _('Show')
        else:
            text = _('Hide')
        self._showhide_button.setText(text)
        self.updateGeometry()


    def terminate(self):
        self._follow_files = False
        for filename,attrs in self._files_followed.items():
            attrs['fp'].close()

    def _create_text_edit(self, parent):
        text = QtWidgets.QPlainTextEdit(parent)
        doc = text.document()
        doc.setMaximumBlockCount(MAX_LINES)
        font = QtGui.QFont()
        font.setFamilies(['Hack','Courier New','monospace'])
        text.setFont(font)
        Highlighter(doc)
        text.setReadOnly(True)
        text.setObjectName('textarea')
        #text.setSizePolicy(QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.MinimumExpanding))
        return text

    def follow(self, filename):
        file = self._files_followed.get(filename)
        if not file:
            if not os.path.exists(filename):
                with open(filename,'w') as fp:
                    fp.write('')
            file = open(filename,'r')
            file.seek(0,2)
            self._files_followed.setdefault(filename,{'fp':file})
            timer = QtCore.QTimer(self)
            timer.timeout.connect(lambda: self._read_logfile(filename))
            timer.start(READLOG_TIMER)
            self._files_followed[filename].setdefault('timer',timer)
            if DEBUG:
                self.msg(_("Following logfile") + f' {filename}')
            return
        fp=file['fp']
        while self._follow_files:
            # lines = []
            # line = fp.readline().rstrip()
            # while line:
            #     lines.append(line)
            #     line = fp.readline().rstrip()
            # return lines
            return fp.read().splitlines()

    def _read_logfile(self, filename):
        lines = self.follow(filename)
        printname = f'[{filename.split("/")[-1]}]'
        self.msg(lines,f'{printname:<25}')

    def msg(self,txt='',prepend=''):
        if txt:
            txtlines=[]
            if isinstance(txt,str):
                txt=txt.strip()
                txtlines = txt.splitlines()
            if isinstance(txt,list):
                txtlines=txt
            for line in txtlines:
                if line:
                    self._textedit.appendPlainText(f'{prepend}{line.capitalize()}')

class MyPyStaticUtils():
    def getTime():
        printtime = time.strftime("[%Y-%m-%d %H:%M:%S]", time.gmtime())
        return f'{printtime:<25}'

    def getTimestamp():
        return time.strftime("%Y%m%d%H%M%S", time.gmtime())

    def getScriptFullPath(scriptname):
        full_scriptname = None
        userhome = os.path.expanduser("~")
        paths = ['/usr/bin',f'{userhome}/llxamp/scripts']
        for path in paths:
            if os.path.exists(f'{path}/{scriptname}'):
                full_scriptname = f'{path}/{scriptname}'
                break
        return full_scriptname

class MyAppConfigFiles():
    APACHE_TAG = 'APACHE'
    PHP_TAG = 'PHP'
    MYSQL_TAG = 'MYSQL'
    CONFIGFILES_TAG = _('Config files')
    LOGFILES_TAG= _('Log files')

    def __init__(self,txt=[]):
        self.tags = [self.APACHE_TAG,self.PHP_TAG,self.MYSQL_TAG]
        self.types = [self.CONFIGFILES_TAG,self.LOGFILES_TAG]
        self.lists = {}
        for tag in self.tags:
            for type in self.types:
                self.lists.setdefault(f'{tag}_{type}',[])

        if txt:
            if isinstance(txt,(list,str)):
                self.set_from_output(txt)
            if isinstance(txt,dict):
                self.set_from_config(txt)

    def to_config(self):
        data = {}
        for tag in self.tags:
            for type in self.types:
                data.setdefault(tag,{})
                data[tag].setdefault(type,self.lists.get(f'{tag}_{type}'))
        return data

    def get_mappings(self):
        return self.get_mappings_from_config(self.to_config())

    def get_mappings_from_config(self, config):
        mappings = {}
        for owner,conf in config.items():
            for what,files in conf.items():
                if files:
                    for file in files:
                        mappings.setdefault(file.split('/')[-1],file)
        return mappings

    def get_logfiles(self):
        return self.get_logfiles_from_config(self.to_config())

    def get_logfiles_from_config(self, config):
        logfiles = []
        for owner,conf in config.items():
            for what,files in conf.items():
                if what == self.LOGFILES_TAG:
                    if files:
                        for file in files:
                            logfiles.append(file)
        return logfiles

    def get_menu(self):
        return self.config_to_menu(self.to_config())

    def config_to_menu(self, config={}):
        menu = []
        for owner,conf in config.items():
            owner_list = [ owner.capitalize() ]
            for what,files in conf.items():
                if files:
                    what_list = [ what.capitalize() ]
                    for file in files:
                        label = os.path.basename(file)
                        what_list.append(label)
                    owner_list.append(what_list)
            menu.append(owner_list)
        return menu

    def output_to_menu(self, text=[]):
        return self.config_to_menu(self.output_to_config(text))

    def set_from_output(self, text=[]):
        cfg = self.output_to_config(text)
        self.set_from_config(cfg)

    def set_from_config(self, cfg={}):
        for tag in self.tags:
            for type in self.types:
                self.lists[f'{tag}_{type}'] = cfg.get(tag).get(type)

    def output_to_config(self, text=[]):
        if isinstance(text,str):
            text=text.splitlines()
        config = {}
        for item in text:
            hint = item.split(':')[0]
            filepath = item.split(':')[1]
            filepath = filepath.strip()
            for tag in self.tags:
                if tag in hint:
                    config.setdefault(tag,{})
                    if 'CONFIG' in hint:
                        config[tag].setdefault(self.CONFIGFILES_TAG,[])
                        config[tag][self.CONFIGFILES_TAG].append(filepath)
                    if 'LOG' in hint:
                        config[tag].setdefault(self.LOGFILES_TAG,[])
                        config[tag][self.LOGFILES_TAG].append(filepath)

        return config

class MyQtStaticUtils():
    def findObject(object,name=''):
        return object.findChildren(QtWidgets.QWidget,QtCore.QRegularExpression(name,QtCore.QRegularExpression.CaseInsensitiveOption))

    def create_menu(items=[], receiver=None, parent=None):
        if isinstance(items,list):
            newmenu = QtWidgets.QMenu(items[0].capitalize(),parent=parent)
            newmenu.setObjectName('menu_'+items[0])
            for subitem in items[1:]:
                if isinstance(subitem,list):
                    newmenu.addMenu(MyQtStaticUtils.create_menu(items=subitem, receiver=receiver, parent=newmenu))
                if isinstance(subitem,str):
                    newmenu.addAction(MyQtStaticUtils.create_menu(items=subitem, receiver=receiver, parent=newmenu))
            return newmenu
        if isinstance(items,str):
            action = QtWidgets.QAction(items.capitalize(),parent=parent)
            action.setData(items)
            action.setObjectName('action_'+items)
            #action.setStatusTip(items)
            #action.setIcon(QtWidgets.QIcon())
            #action.setShortCuts(QtCore.QKeySequence())
            action.triggered.connect(receiver)
            return action

class QtProc():
    def __init__(self):
        self.process = {}

    def executeSingletonScript(self, scriptname, arguments, started_fn=None, finished_fn=None, debug_fn=None, detached=False):

        def process_stdout(process):
            p = self.process.get(process)
            if p:
                data = bytes(p[0].readAllStandardOutput()).decode('utf8').strip()
                return data
            return ''

        def process_stderr(process):
            p = self.process.get(process)
            if p:
                data = bytes(p[0].readAllStandardError()).decode('utf8').strip()
                return data
            return ''

        if not DEBUG:
            debug_fn = lambda x: None

        if not debug_fn:
            debug_fn = print

        debug_start_fn = lambda: debug_fn(f'{MyPyStaticUtils.getTime()} Started {scriptname}')
        debug_finish_fn = lambda x,y: debug_fn(f'{MyPyStaticUtils.getTime()} Finished {scriptname}\n{x}\n')

        if not started_fn:
            started_fn = debug_start_fn

        if not finished_fn:
            finished_fn = debug_finish_fn

        if self.process.get(scriptname):
            debug_fn(_("Already running") + f' {scriptname}')
            return

        process = QtCore.QProcess()
        process.setObjectName(scriptname)

        def sfn():
            self.process.setdefault(scriptname, [process])
            debug_start_fn()
            started_fn()

        def ffn():
            out = process_stdout(scriptname)
            err = process_stderr(scriptname)
            if err:
                debug_finish_fn(_("Error executing script") + f' {scriptname}',None)
            debug_finish_fn(out,err)
            finished_fn(out,err)
            if scriptname in self.process:
                del self.process[scriptname]

        fn_start = sfn
        fn_finish = ffn

        process.finished.connect(fn_finish)
        process.started.connect(fn_start)

        if detached:
            process.startDetached(MyPyStaticUtils.getScriptFullPath(scriptname),arguments)
        else:
            process.start(MyPyStaticUtils.getScriptFullPath(scriptname),arguments)

class Monitor(QtWidgets.QWidget):

    tickData = QtCore.Signal(str)

    def __init__(self, *args, **kwargs):
        super().__init__(*args)
        if not self.layout():
            self.setLayout(QtWidgets.QHBoxLayout(self))
        self.layout().setMargin(0)

        self.timeout = kwargs.get('timeout',30000)
        self._debug_fn = kwargs.get('debug_fn',print)
        self._proc = QtProc()
        self._timer = QtCore.QTimer()
        self._timer.timeout.connect(self.makeTick)
        self._contents = {}
        self._labels = ['apache','mysql']

        self._add_labels(self._labels)
        self._add_content_to_layout()

    def _add_labels(self, labels):
        if not isinstance(labels,list):
            labels = [labels]
        for label in labels:
            labelobj = QtWidgets.QLabel('[no data yet]',self)
            labelobj.setIndent(8)
            labelobj.setSizePolicy(QtWidgets.QSizePolicy.Fixed,QtWidgets.QSizePolicy.Fixed)
            font = QtGui.QFont()
            font.setFamilies(['Hack','Courier New','monospace'])
            font.setPointSize(10)
            labelobj.setFont(font)
            self._contents.setdefault(f'label_{label}',labelobj)

    def _add_content_to_layout(self):
        for k,v in self._contents.items():
            self.layout().addWidget(v)

    def start(self):
        self.makeTick()
        self._timer.start(self.timeout)

    def makeTick(self):
        self._proc.executeSingletonScript(
                'llxamp-status', ['-a','-m','-p','-n'],
                debug_fn=self._debug_fn,
                finished_fn=self._tick_process_result
            )

    def _tick_process_result(self, result=None, err=None):
        if result:
            data = { item[0]:item[1] for item in [line.upper().split('=') for line in result.splitlines()] }
            red_palette = QtGui.QPalette()
            red_palette.setColor(QtGui.QPalette.WindowText,QtCore.Qt.red)
            green_palette = QtGui.QPalette()
            green_palette.setColor(QtGui.QPalette.WindowText,QtCore.Qt.darkGreen)
            notrunstr = _("Not running")
            if data.get('APACHE_RUNNING') == '0':
                label = self._contents.get('label_apache')
                label.setText(f'[Apache: {notrunstr}]')
                label.setPalette(red_palette)
            else:
                label = self._contents.get('label_apache')
                label.setText(f"[Apache: ports={data.get('APACHE_PORTS')} {len(data.get('APACHE_PROCS','').split(','))} procs]")
                label.setPalette(green_palette)
            if data.get('MYSQL_RUNNING') == '0':
                label = self._contents.get('label_mysql')
                label.setText(f'[MySQL: {notrunstr}]')
                label.setPalette(red_palette)
            else:
                label = self._contents.get('label_mysql')
                label.setText(f"[MySQL: ports={data.get('MYSQL_PORTS')} {len(data.get('MYSQL_PROCS','').split(','))} procs]")
                label.setPalette(green_palette)
            self.tickData.emit(result)

class MainApp(QtWidgets.QMainWindow):
    def __init__(self, app, *args, **kwargs):
        super().__init__()
        self.app = app
        self.qtproc = QtProc()
        self.logviewer = LogViewer(self)
        self.monitor = Monitor(self,timeout=STATUS_TIMER,debug_fn=self.msg)
        self.statusBar().addWidget(self.monitor)
        self.monitor.start()
        self.timers = {}
        self.file_mappings = {}

        self.setWindowTitle('LLXAMP')
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)

        self.setWindowIcon(icon)

        self.setMinimumSize(QtCore.QSize(800,600))

        self.setCentralWidget(QtWidgets.QWidget(parent=self))
        self.centralWidget().setSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)

        self.begin_build_menubar()
        self.create_layout()
        self.create_tabs()
        self.create_buttons()
        self.split.addWidget(self.logviewer)
        self.split.setStretchFactor(self.split.count()-1,1)

        self.create_systray()
        if DEBUG:
            msg = []
            for k in os.environ.keys():
                msg.append(f'{k} = {os.environ.get(k)}')
            self.msg('\n'.join(msg))

    def changed_tab(self,idx):
        if DEBUG:
            self.msg(f'TAB CHANGE {idx}')

    def close_tab(self,idx,exit_forced=False):
        tabs = MyQtStaticUtils.findObject(self,'tabs')
        if not tabs:
            return False
        tabs = tabs[0]
        widget = tabs.widget(idx)
        if not exit_forced and widget.isChanged():
            dialog = QtWidgets.QMessageBox.question(
                self,
                _("Close tab"),
                _("Do you want close the tab?") + f' "{widget.data()}"',
                QtWidgets.QMessageBox.Yes|QtWidgets.QMessageBox.No
            )
            if dialog == QtWidgets.QMessageBox.No:
                return False
        if DEBUG:
            self.msg(_("TAB CLOSE") + f' {idx}')

        if hasattr(widget,'askSave'):
            ret = widget.askSave()
            if not ret:
                return False
        widget.deleteLater()
        tabs.removeTab(idx)
        if tabs.count() == 0:
            tabs.setVisible(False)
        return True

    def create_tabs(self):
        tabs = QtWidgets.QTabWidget(self)
        tabs.setObjectName('tabs')
        tabs.setTabsClosable(True)
        tabs.currentChanged.connect(self.changed_tab)
        tabs.tabCloseRequested.connect(self.close_tab)
        # text = QtWidgets.QPlainTextEdit()
        # text.setObjectName('tab_exampletab1')
        # tabs.addTab(text,'exampletab1')
        self.split.addWidget(tabs)
        self.split.setStretchFactor(self.split.count()-1,10)
        tabs.setVisible(False)

    def begin_build_menubar(self):
        menu_context_items = ['Llxamp', _('Exit') ]
        menu_context = MyQtStaticUtils.create_menu(
            items=menu_context_items,
            receiver=self.action_triggered,
            parent=self.menuBar()
        )
        self.menuBar().addMenu(menu_context)

        def post_actions(x,err):
            x = MyAppConfigFiles(x)
            self.update_menu_bar(data=x)
            if x:
                self.file_mappings = x.get_mappings()
                for f in x.get_logfiles():
                    self.logviewer.follow(f)

        if llxconfig:
            cfg = MyAppConfigFiles()

            llxconfig.set_mode_apache()
            hierarchy, includes, content, logs=llxconfig.process()
            cfg.lists[f'{cfg.APACHE_TAG}_{cfg.CONFIGFILES_TAG}'] = includes
            cfg.lists[f'{cfg.APACHE_TAG}_{cfg.LOGFILES_TAG}'] = logs

            llxconfig.set_mode_php()
            hierarchy2, includes2, content2, logs2=llxconfig.process()
            cfg.lists[f'{cfg.PHP_TAG}_{cfg.CONFIGFILES_TAG}'] = includes2
            cfg.lists[f'{cfg.PHP_TAG}_{cfg.LOGFILES_TAG}'] = logs2

            llxconfig.set_mode_mysql()
            hierarchy3, includes3, content3, logs3=llxconfig.process()
            cfg.lists[f'{cfg.MYSQL_TAG}_{cfg.CONFIGFILES_TAG}'] = includes3
            cfg.lists[f'{cfg.MYSQL_TAG}_{cfg.LOGFILES_TAG}'] = logs3
            post_actions(cfg.to_config(),None)
        else:

            self.qtproc.executeSingletonScript(
                'llxamp-config',['-a','-p','-m','-t','-i','-l'],
                finished_fn=post_actions,
                debug_fn=self.msg
            )

    def closeEvent(self,ev=None,*args):
        for tabs in MyQtStaticUtils.findObject(self,'tabs'):
            if tabs.objectName() == 'tabs':
                for idx in range(tabs.count()):
                    widget=tabs.widget(idx)
                    if isinstance(widget,Editor):
                        if not self.close_tab(idx,exit_forced=True):
                            if hasattr(ev,'ignore'):
                                ev.ignore()
                            return
        self.logviewer.terminate()

        print(_('Exit'))
        super().closeEvent(ev)
        self.app.quit()

    def systray_activation(self,reason):
        mode = reason.name.decode().lower()
        if mode == 'context':
            print(mode)
        elif mode == 'trigger':
            self.setVisible(not self.isVisible())
        else:
            print(f'TODO: {mode}')

    def create_systray(self):
        fallback = QtGui.QIcon(ICON)
        fallback.setThemeName('hicolor')
        icon = QtGui.QIcon.fromTheme('llxamp',fallback)
        self.systray = QtWidgets.QSystemTrayIcon(icon,self)

        self.systray.setVisible(True)
        self.systray.activated.connect(self.systray_activation)
        self.systray.setToolTip("LliureX Apache+MySQL+PHP")

        menu = MyQtStaticUtils.findObject(self,'menu_llxamp')
        if not menu:
            return False
        menu = menu[0]
        self.systray.setContextMenu(menu)

    def create_layout(self):
        l = QtWidgets.QVBoxLayout()
        self.centralWidget().setObjectName('main_layout')
        self.centralWidget().setLayout(l)
        self.split=QtWidgets.QSplitter(self)
        self.split.setOrientation(QtCore.Qt.Vertical)
        self.split.setChildrenCollapsible(False)
        l.addWidget(self.split)
        self.split.setMinimumSize(0,0)
        self.split.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.MinimumExpanding)

    def update_menu_bar(self, data=None):
        items = []
        if not isinstance(data,MyAppConfigFiles):
            data = MyAppConfigFiles(data)
        items = data.get_menu()

        # items_example = [
        #     ['File', ['Action1',['SubFile', 'Action2'], 'Action3'] ],
        #     ['File2', [Action4, Action5] ],
        #     Action6
        # ]

        for item in items:
            if isinstance(item,list):
                self.menuBar().addMenu(
                    MyQtStaticUtils.create_menu(
                        items = item,
                        receiver = self.action_triggered,
                        parent = self.menuBar()
                    )
                )
            if isinstance(item,str):
                self.menuBar().addAction(
                    MyQtStaticUtils.create_menu(
                        items = item,
                        receiver = self.action_triggered,
                        parent=self.menuBar()
                    )
                )

    def modification_slot(self,*args):
        # self.msg(f'Document changed {args}')
        sender = self.sender()
        tab = sender.parent().parent()
        idx = tab.indexOf(sender)
        icon = self.style().standardIcon(getattr(QtWidgets.QStyle,'SP_DialogSaveButton'))

        if sender.isChanged():
            tab.setTabIcon(idx,icon)
        else:
            tab.setTabIcon(idx,QtGui.QIcon())

    def editor_save_slot(self):
        self.menuBar().clear()
        self.begin_build_menubar()


    def new_tab(self, filename):
        name = filename.split('/')[-1]
        tabs = MyQtStaticUtils.findObject(self,'tabs')
        if not tabs:
            return False
        tabs = tabs[0]
        tab = MyQtStaticUtils.findObject(self,f'tab_{name}')
        if not tab:
            font = QtGui.QFont()
            font.setFamilies(['Hack','Courier New','monospace'])
            font.setPointSize(10)
            text = Editor(self.file_mappings.get(filename))
            text.setObjectName(f'tab_{name}')
            text.setFont(font)
            text.setData(filename)
            text.editorModified.connect(self.modification_slot)
            text.editorSaved.connect(self.editor_save_slot)
            text.editorExternal.connect(self.action_triggered)
            tabs.addTab(text,name)
            tabs.setCurrentIndex(tabs.count()-1)
            if DEBUG:
                self.msg(_("Tab created") + f' {tabs.count()}')
        else:
            idx = tabs.indexOf(tab[0])
            tabs.setCurrentIndex(idx)
        tabs.setVisible(True)

    def action_triggered(self, name=None):
        action_sender = self.sender()
        parent_name = ''
        if hasattr(action_sender,'parent'):
            parent_name = action_sender.parent().objectName()
        text = None
        data = None
        if action_sender:
            if hasattr(action_sender,'text'):
                text = action_sender.text()
            if hasattr(action_sender,'data'):
                data = action_sender.data()
            if not name:
                name = action_sender.objectName()
        if DEBUG:
            self.msg(f'{MyPyStaticUtils.getTime()} Action trigger {name}')
        txt=[]
        if name:
            txt.append(f'objectName={name}')
        if data:
            txt.append(f'data={data}')
        if text:
            txt.append(f'text={text}')
        if txt:
            txt = ','.join(txt)

        if name == 'external-edit':
            self.qtproc.executeSingletonScript(
                'xdg-open', [action_sender._filename],
                debug_fn=self.msg,
                detached=True
            )
        if name[:6] == 'action':
            if parent_name.lower() == 'menu_llxamp':
                if text.lower() == 'exit':
                    self.closeEvent()
            else:
                file = data
                if DEBUG:
                    self.msg(_("Editing") + f' {file}')
                self.new_tab(file)
                pass

        if name[:6] == 'button':
            button = MyQtStaticUtils.findObject(self,name)
            if button:
                button = button[0]
            cmd = name.split('_')[1]
            scriptname = f'llxamp-{cmd}'
            args = []
            prepend=''
            print_output_to=self.msg
            if cmd == 'make-backup':
                filter = _('Archive files')+' (*.tar.gz)'
                path,filter_selected = QtWidgets.QFileDialog.getSaveFileName(self,_('File to save'),os.path.expanduser('~'),filter)
                if not path:
                    return
                args = ['-o',path]
            if cmd == 'status':
                args = ['-a','-m','-p','-n']
            if cmd == 'config':
                if not llxconfig:
                    args = ['-a','-p','-c','-r']
                else:
                    llxconfig.set_mode_apache()
                    tree,includes,content,logs = llxconfig.process()
                    txt = llxconfig.print_content(content,False,False)
                    llxconfig.set_mode_php()
                    tree2,includes2,content2,logs = llxconfig.process()
                    txt = f'{txt}{llxconfig.print_content(content2,False,False)}'
                    self.msg(txt,prepend)
                    return
            if cmd == 'show-available-ports':
                # print_output_to = lambda x: (self.infodialog(title=_("Available ports"),txt=x),self.msg(x))
                print_output_to = lambda x: self.infodialog(title=button.text(),txt=x)
            if cmd == 'show-used-ports':
                scriptname = 'llxamp-ports'
                args = ['-u']
                print_output_to = lambda x: self.infodialog(title=button.text(),txt=x)
            # Common "output" parameter for button actions
            def output(x,err):
                if DEBUG:
                    self.msg(_('Output from command') + f' {scriptname}:\nSTDOUT\n{x}\nSTDERR{err}\n',prepend)
                if err:
                    print_output_to(_('Error Output') + f'---> "{err}"')
                print_output_to(x)
                button.setEnabled(True)
                if cmd == 'status':
                    self.update_status_bar(data=x)
                else:
                    QtCore.QTimer.singleShot(3000,self.monitor.makeTick)

            self.qtproc.executeSingletonScript(
                scriptname, args,
                started_fn=lambda: button.setDisabled(True),
                finished_fn=lambda x,y: output(x,y),
                debug_fn=self.msg
            )

    def infodialog(self, *args, **kwargs):
        title=kwargs.get('title','')
        txt=kwargs.get('txt','')

        txt=txt.split(',')
        txt=', '.join(txt)

        dialog = QtWidgets.QMessageBox()
        dialog.setText(f'<h3>{txt}</h3>')
        dialog.setWindowTitle(title)
        dialog.setStandardButtons(QtWidgets.QMessageBox.Ok)
        dialog.setIcon(QtWidgets.QMessageBox.Information)

        dialog.exec_()

    def toggle(self):
        button = self.sender()
        print(f'Checked={button.isChecked()}')
        buttons = [ child for child in button.parent().children() if isinstance(child,QtWidgets.QToolButton) and child.objectName()[:7] == 'button_' ]
        if button.isChecked():
            for btn in buttons:
                btn.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
            button.setIcon(self._iconBack)
            button.setChecked(False)
        else:
            for btn in buttons:
                btn.setToolButtonStyle(QtCore.Qt.ToolButtonTextBesideIcon)
            button.setIcon(self._iconForward)
            button.setChecked(True)

    def create_buttons(self):
        if not hasattr(self,'_iconBack'):
            self._iconBack = self.style().standardIcon(getattr(QtWidgets.QStyle,'SP_ArrowBack'))
        if not hasattr(self,'_iconForward'):
            self._iconForward = self.style().standardIcon(getattr(QtWidgets.QStyle,'SP_ArrowForward'))

        toolbar = QtWidgets.QToolBar(self.centralWidget().parent())
        toolbar.setFloatable(False)
        toolbar.setMovable(False)
        toolbar.setOrientation(QtCore.Qt.Vertical)
        toolbar.setStyleSheet('border:none;')
        toolbar.setIconSize(QtCore.QSize(32,32))

        button = QtWidgets.QToolButton(toolbar)
        button.setObjectName('toggle_button')
        button.setIcon(self._iconBack)
        button.setCheckable(True)
        button.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
        button.pressed.connect(self.toggle)
        toolbar.addWidget(button)
        #toolbar.setContentsMargins(10,10,10,10)

        buttons = [
            ("start","Start",("media-playback-start","SP_MediaPlay")),
            ("stop","Stop",("media-player-stop","SP_MediaStop")),
            ("open-browser",_("Browser"),("internet-web-browser","SP_DriveNetIcon")),
            ("open-browser-ssl",_("Secure browser"),("preferences-web-browser-ssl","SP_DriveNetIcon")),
            ("open-phpmyadmin",_("PhpMyAdmin"),("server-database","SP_FileDialogInfoView")),
            ("show-used-ports",_("Used ports"),("network-wired","SP_TitleBarNormalButton")),
            ("show-available-ports",_("Available ports"),("network-wired-disconnected","SP_TitleBarNormalButton")),
            ("make-backup",_("Make backup"),("utilities-file-archiver","SP_DriveFDIcon")),
            ("show-apache-config",_("Show Apache config"),("/usr/share/applications/llxamp-apache.svg","description","SP_FileIcon"))
        ]
        maxsize=max([ len(button[2]) for button in buttons])
        for pack in buttons:
            if isinstance(pack,tuple):
                if len(pack) == 3:
                    cmd, txt, icons = pack
                    if cmd[0] == '#':
                        continue

                    if isinstance(icons,str):
                        theme = 'help-about'
                        fallback = 'SP_TitleBarContextHelpButton'
                        custom = icons
                    else:
                        if isinstance(icons,tuple):
                            if len(icons) == 2:
                                custom = None
                                theme, fallback = icons
                            if len(icons) == 3:
                                custom , theme , fallback = icons

                    icon = QtGui.QIcon()
                    if custom:
                        icon = QtGui.QIcon(custom)
                    if icon.isNull():
                        icon = QtGui.QIcon.fromTheme(theme,self.style().standardIcon(getattr(QtWidgets.QStyle,fallback)))
                    if icon.isNull():
                        icon = self.style().standardIcon(getattr(QtWidgets.QStyle,fallback))

                    btn = QtWidgets.QToolButton(toolbar)
                    if icon:
                        btn.setIcon(icon)
                    btn.setText(txt.capitalize())
                    btn.setCheckable(True)
                    btn.setToolButtonStyle(QtCore.Qt.ToolButtonIconOnly)
                    btn.setObjectName('button_'+cmd)
                    btn.setToolTip(txt.capitalize())
                    btn.pressed.connect(self.action_triggered)
                    btn.setSizePolicy(QtWidgets.QSizePolicy.Expanding,QtWidgets.QSizePolicy.Fixed)
                    toolbar.addWidget(btn)

        # Needed for align items on old pyside versions
        # Breaks full size button until qtoolbar width
        # test with btn.setStyleSheet('background-color: green')
        layout = toolbar.layout()
        for i in range(layout.count()):
            item = layout.itemAt(i)
            item.setAlignment(QtCore.Qt.AlignLeft)

        self.centralWidget().parent().addToolBar(QtCore.Qt.RightToolBarArea,toolbar)

    # def create_buttons2(self):
    #     container = QtWidgets.QWidget(self.split)
    #     container.setObjectName('container_buttons')
    #     if not container.layout():
    #         container.setLayout(QtWidgets.QHBoxLayout(container))
    #     container.layout().setMargin(0)

    #     buttons = ["#status","start","stop","#config",("open-browser",_('Open browser')),("open-browser-ssl",_('Open Secure Browser')),("open-phpmyadmin",_("PhpMyAdmin"))]
    #     for txt in buttons:
    #         if isinstance(txt,tuple):
    #             cmd,txt = txt
    #         else:
    #             cmd = txt
    #         if txt[0] != '#':
    #             btn = QtWidgets.QPushButton(txt.capitalize(),parent=container)
    #             btn.setObjectName('button_'+cmd)
    #             btn.pressed.connect(self.action_triggered)
    #             container.layout().addWidget(btn)
    #     self.centralWidget().layout().addWidget(container)

    def msg(self, txt='', prepend=''):
        self.logviewer.msg(txt,prepend)

def main():
    global app, exitting, DEBUG
    try:
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        s.bind('\0llxamp')
    except Exception as e:
        print(_("Already running"))
        sys.exit(0)
    for arg in sys.argv:
        if arg.lower() == '-d':
            DEBUG=True
    app = QtWidgets.QApplication(sys.argv)
    window = MainApp(app)
    window.show()
    exitLoopTimer = QtCore.QTimer()
    exitLoopTimer.timeout.connect(lambda: None)
    exitLoopTimer.start(EXIT_TIMER)
    sys.exit(app.exec_())

if __name__ == '__main__':
    main()

